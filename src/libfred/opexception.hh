/*
 * Copyright (C) 2012  CZ.NIC, z.s.p.o.
 *
 * This file is part of FRED.
 *
 * FRED is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * FRED is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with FRED.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 *  @file opexception.h
 *  operation exceptions
 */

#ifndef OPEXCEPTION_HH_CD4D595579FB4E3CBA845B23423113F3
#define OPEXCEPTION_HH_CD4D595579FB4E3CBA845B23423113F3

#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/types.h>
#include <assert.h>
#include <string>
#include <vector>
#include <map>

#include <algorithm>
#include <functional>
#include <boost/function.hpp>
#include <boost/exception/all.hpp>

#include "src/libfred/db_settings.hh"

namespace LibFred
{
/**
 * Exception stack context info.
 */
struct ExceptionStack
: virtual boost::exception
{
    /**
    * String tag to record/append operation stack context.
    */
    typedef boost::error_info<struct OperationStackTag,std::string> ErrorInfoOperationStack;

    /**
    * Append operation stack context.
    * @param info string to be appended to the exception data
    */
    void add_exception_stack_info(const std::string& info)
    {
        std::string operation_stack_info;
        const std::string* ptr = 0;
        ptr = get_data_ptr();
        if(ptr) operation_stack_info += *ptr;
        operation_stack_info += info;
        (*this) << ErrorInfoOperationStack(operation_stack_info);
    }

    /**
     * Get current exception stack info data.
     * @return exception stack text
     */
    std::string get_exception_stack_info() const
    {
        const std::string* data_ptr = get_data_ptr();
        return data_ptr ? *data_ptr : std::string();
    }

    /**
     * Check if exception stack info is set.
     */
    bool is_set_exception_stack_info() const
    {
        const std::string* data_ptr = get_data_ptr();
        return data_ptr;
    }

    /**
     * Public virtual nothrow empty dtor.
     */
    virtual ~ExceptionStack() {}

private:

    /**
     * Get pointer to exception stack data.
     */
    const std::string* get_data_ptr() const
    {
        return boost::get_error_info<ErrorInfoOperationStack>(*this);
    }
};

/**
 * Exception data set flag.
 */
struct ThrowMeFlagImpl
{
private:
    bool throw_me_;
public:
    /**
     * Check if exception instance have set content to be thrown.
     *@return true if exception data is set then throw exception
     */
    bool throw_me() const
    {
        return throw_me_;
    }
    /**
     * Set to indicate throw.
     * Setter is called by exception data setters or directly if using operator<< with error_info type.
     */
    void set_throw_me()
    {
        throw_me_ = true;
    }
protected:
    /**
     * Ctor with initial throw_me_ value false, have meaning nothing to be thrown
     */
    ThrowMeFlagImpl()
    : throw_me_(false)
    {}
    /**
    * Protected non-virtual nothrow empty dtor.
    */
    ~ThrowMeFlagImpl() {}
};

/**
 * Parent of operation exceptions.
 */
struct OperationException
    : virtual std::exception
    , virtual ExceptionStack
    , virtual ThrowMeFlagImpl
{
    /**
     * std::exception content override
     */
    const char* what() const noexcept
    {
        return "OperationException";
    }
    /**
     * Public virtual nothrow empty dtor.
     */
    virtual ~OperationException() {}
};

/**
 * Internal error exception with describing message.
 */
struct InternalError
: virtual std::exception
, virtual ExceptionStack
{
    explicit InternalError(std::string const& message)
        : msg_(message)
        {}
    explicit InternalError(const char* message)
    : msg_(message)
    {}
    /**
     * std::exception content override
     */
    virtual const char* what() const noexcept
    {
        try
        {
            return msg_.c_str();
        }
        catch(...)
        {}
        return "error: std::string::c_str() exception";
    }

    virtual ~InternalError() try{}catch(...){}
private:
    std::string msg_;
};


/**
* Declaration of exception tag related methods getter and chaining setter with error_info type.
*/
#define DECLARE_EXCEPTION_DATA(ex_data_tag, ex_data_type) \
typedef boost::error_info<BOOST_JOIN(struct ExceptionTag_,ex_data_tag),ex_data_type> BOOST_JOIN(ErrorInfo_,ex_data_tag);/**< Type generated by macro @ref DECLARE_EXCEPTION_DATA used for identification of attribute within boost::exception instance*/\
template <class DERIVED_EXCEPTION> struct BOOST_JOIN(ExceptionData_,ex_data_tag)\
{\
public:\
    typedef BOOST_JOIN(ErrorInfo_,ex_data_tag) error_info_type;/**< boost::error_info tag alias used for identification of attribute within boost::exception instance*/\
private:\
\
    const DERIVED_EXCEPTION* get_derived_ptr() const\
    {\
        return static_cast<const DERIVED_EXCEPTION*>(this);\
    }\
    const ex_data_type* get_data_ptr() const\
    {\
        return boost::get_error_info<error_info_type>(*(get_derived_ptr()));\
    }\
public:\
    /** Setter of the boost::exception attribute. @param arg attribute value to be set @return exception reference to allow method chaining */\
    DERIVED_EXCEPTION& BOOST_JOIN(set_,ex_data_tag)(const ex_data_type& arg)\
    {\
        DERIVED_EXCEPTION& ex = *static_cast<DERIVED_EXCEPTION*>(this);\
        ex << error_info_type(arg);\
        ex.set_throw_me();\
        return ex;\
    }\
    /** Getter of the boost::exception attribute. @return value of exception attribute identified by @ref error_info_type */\
    ex_data_type BOOST_JOIN(get_,ex_data_tag)() const\
    {\
        const ex_data_type* data_ptr = get_data_ptr();\
        return data_ptr ? *data_ptr : error_info_type::value_type();\
    }\
    /** Check if the attribute of boost::exception is set. @return true if set, false if not set */\
    bool BOOST_JOIN(is_set_,ex_data_tag)() const\
    {\
        const ex_data_type* data_ptr = get_data_ptr();\
        return data_ptr;\
    }\
protected:\
    BOOST_JOIN(ExceptionData_,ex_data_tag)(){}\
    BOOST_JOIN(~ExceptionData_,ex_data_tag)() {}\
}\

/**
* Declaration of std::vector based exception tag related methods, getter and chaining setter with error_info type
 */
#define DECLARE_VECTOR_OF_EXCEPTION_DATA(ex_data_tag, ex_data_type) \
typedef boost::error_info<BOOST_JOIN(struct ExceptionTag_vector_of_,ex_data_tag), std::vector<ex_data_type> > BOOST_JOIN(ErrorInfo_vector_of_,ex_data_tag);/**< Type generated by macro @ref DECLARE_VECTOR_OF_EXCEPTION_DATA used for identification of attribute vector within boost::exception instance*/\
\
static std::string to_string(const BOOST_JOIN(ErrorInfo_vector_of_,ex_data_tag)& info)/**< Print vector data using std::ostringstream into std::string separated by spaces*/\
{\
    std::ostringstream oss;\
    oss << "vector data:";\
    for(BOOST_JOIN(ErrorInfo_vector_of_,ex_data_tag)::value_type::const_iterator ci = info.value().begin()\
            ; ci != info.value().end(); ++ci) oss << ' ' << *ci;\
    return oss.str();\
}\
\
template <class DERIVED_EXCEPTION> struct BOOST_JOIN(ExceptionData_vector_of_,ex_data_tag)\
{\
public:\
    typedef BOOST_JOIN(ErrorInfo_vector_of_,ex_data_tag) error_info_type;/**< boost::error_info tag alias used for identification of attribute vector within boost::exception instance*/\
private:\
\
    const DERIVED_EXCEPTION* get_derived_ptr() const\
    {\
        return static_cast<const DERIVED_EXCEPTION*>(this);\
    }\
    const std::vector<ex_data_type>* get_data_ptr() const\
    {\
        return boost::get_error_info<error_info_type>(*(get_derived_ptr()));\
    }\
public:\
    /** Setter of the boost::exception vector attribute. @param arg attribute value to be set @return exception reference to allow method chaining */\
    DERIVED_EXCEPTION& BOOST_JOIN(set_vector_of_,ex_data_tag)(const std::vector<ex_data_type>& arg)\
    {\
        DERIVED_EXCEPTION& ex = *static_cast<DERIVED_EXCEPTION*>(this);\
        ex << error_info_type(arg);\
        ex.set_throw_me();\
        return ex;\
    }\
    /** Getter of the boost::exception vector attribute. @return value of the vector attribute identified by @ref error_info_type */\
    std::vector<ex_data_type> BOOST_JOIN(get_vector_of_,ex_data_tag)() const \
    {\
        const std::vector<ex_data_type>* data_ptr = get_data_ptr();\
        return data_ptr ? *data_ptr : std::vector<ex_data_type>();\
    }\
    /** Check if the vector attribute of boost::exception is set. @return true if set, false if not set */\
    bool BOOST_JOIN(is_set_vector_of_,ex_data_tag)() const\
    {\
        const std::vector<ex_data_type>* data_ptr = get_data_ptr();\
        return data_ptr;\
    }\
    /** Add element into the vector attribute of the boost::exception. @param arg element value to be added @return exception reference to allow method chaining */\
    DERIVED_EXCEPTION& BOOST_JOIN(add_,ex_data_tag)(const ex_data_type& arg)\
    {\
        std::vector<ex_data_type> data_vector = BOOST_JOIN(get_vector_of_,ex_data_tag)();\
        data_vector.push_back(arg);\
        return BOOST_JOIN(set_vector_of_,ex_data_tag)(data_vector);\
    }\
protected:\
    BOOST_JOIN(ExceptionData_vector_of_,ex_data_tag)(){}\
    BOOST_JOIN(~ExceptionData_vector_of_,ex_data_tag)() {}\
}\

///common exception data tags

/**
* ExceptionTraits template is meant to map operations types to exceptions types.
*  @param T is type of derived operation or other custom type.
*  Exception types are expected in specializations of the template for type T.
 */
template <class T> struct ExceptionTraits;


} // namespace LibFred
#endif
