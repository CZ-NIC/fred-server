/*
 * Copyright (C) 2011-2019  CZ.NIC, z. s. p. o.
 *
 * This file is part of FRED.
 *
 * FRED is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * FRED is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with FRED.  If not, see <https://www.gnu.org/licenses/>.
 */
/**
 *  @file subprocess.h
 *  sub-process related utils
 */


#ifndef SUBPROCESS_HH_A539E3A3E3B4436D828087C418ADE5A2
#define SUBPROCESS_HH_A539E3A3E3B4436D828087C418ADE5A2

#include <sys/types.h>
#include <sys/wait.h>
#include <sys/time.h>

#include <string>
#include <vector>
#include <cstdlib>

#include <boost/noncopyable.hpp>

/**
 * @class SubProcessOutput
 * @brief command outputs and process exit status
 * 
 * Result of process's run.
 */
struct SubProcessOutput
{
    std::string stdout; /**< contains standard output generated by process */
    std::string stderr; /**< contains error output generated by process */
    int status; /**< exit status of process */

    /**
     * Terminated normally
     * @return true if process terminated normally, that is, by calling exit
     *         or _exit, or by returning from main()
     */
    bool is_exited()const { return WIFEXITED(status); }

    /**
     * Exit status of the normally terminated process
     * @return The exit status of the child. This consists of the least significant
     *         8 bits of the status argument that the child specified in a call to
     *         exit or _exit or as the argument for a return statement in main().
     * @note @ref is_exited() must be true
     */
    int get_exit_status()const { return WEXITSTATUS(status); }

    /**
     * Process successfully finished
     * @return true if process finished successfully
     */
    bool succeeded()const { return this->is_exited() && this->get_exit_status() == EXIT_SUCCESS; }

    /**
     * Terminated by a signal
     * @return true if the child process was terminated by a signal
     */
    bool is_signaled()const { return WIFSIGNALED(status); }

    /**
     * Number of the signal
     * @return the number of the signal that caused the child process to terminate
     * @note @ref is_signaled() must be true
     */
    int get_term_sig()const { return WTERMSIG(status); }

#ifdef WCOREDUMP
    /**
     * Produced a core dump
     * @return true if the child process produced a core dump
     */
    bool is_core_dump()const { return this->is_signaled() && (WCOREDUMP(status)); }
#endif
};

namespace Cmd
{

class Data;

/**
 * @class Executable
 * @brief wrapper of exec() functions family
 */
class Executable:public boost::noncopyable
{
public:
    /**
     * Execute command @arg _cmd using execv/execvp function in forked child process.
     * @param _cmd executable file
     * @throw std::runtime_error if something wrong happens
     * 
     * Run <em>_cmd [args...]</em>
     */
    Executable(std::string _cmd);

    ~Executable() { }
    
    /**
     * Add command argument.
     */
    Executable& operator()(std::string _arg);

    /**
     * Wait as long as command runs.
     * @return Command's standard and error outputs and its exit status.
     * @throw std::runtime_error if something wrong happens
     * @note Sets and restores SIGCHLD handler.
     */
    SubProcessOutput run();

    /**
     * @class Seconds
     * @brief Represents time meassured in seconds.
     */
    typedef decltype(::timeval().tv_sec) Seconds;

    /**
     * Wait as long as command runs, at most _max_lifetime_sec seconds.
     * @param _max_lifetime_sec maximal command lifetime in seconds
     * @return Command's standard and error outputs and its exit status.
     * @throw std::runtime_error if something wrong happens
     * @note Sets and restores SIGCHLD handler.
     */
    SubProcessOutput run(Seconds _max_lifetime_sec);

    /**
     * Wait as long as command runs.
     * @param _search_path 
     * @return Command's standard and error outputs and its exit status.
     * @throw std::runtime_error if something wrong happens
     * @note Sets and restores SIGCHLD handler. Searches executable file
     *       considering PATH environment variable - it's less safe variant.
     */
    SubProcessOutput run_with_path();

    /**
     * Wait as long as command runs, at most _max_lifetime_sec seconds.
     * @param _max_lifetime_sec maximal command lifetime in seconds
     * @return Command's standard and error outputs and its exit status.
     * @throw std::runtime_error if something wrong happens
     * @note Sets and restores SIGCHLD handler. Searches executable file
     *       considering PATH environment variable - it's less safe variant.
     */
    SubProcessOutput run_with_path(Seconds _max_lifetime_sec);
private:
    Executable(std::string _data, std::string _cmd);
    const std::string data_;
    const std::string cmd_;
    typedef std::vector< std::string > Args;
    Args args_;
    friend class Data;
};//class Executable

/**
 * @class Data
 * @brief Contains data for dispatching to the process via standard input stream.
 */
class Data:public boost::noncopyable
{
public:
    /**
     * Store data.
     * @param _data contains data for dispatching to the process via standard input stream
     */
    Data(std::string _data);
    ~Data();
    /**
     * Connects data with process.
     * @param _cmd command for execution
     */
    Executable& into(std::string _cmd);
private:
    Executable *cmd_;
    const std::string data_;
};

}

/**
 * @class ShellCmd
 * @brief shell command wrapper
 * @warning With externally gained data use @ref Cmd::Executable instead!
 *          There is a danger of security incident (shell injection).
 */
class ShellCmd:public boost::noncopyable
{
public:
    /**
     * @class RelativeTimeInSeconds
     * @brief Represents relative (from now) time meassured in seconds.
     */
    typedef Cmd::Executable::Seconds RelativeTimeInSeconds;

    /**
     * Constructor with mandatory parameters.
     * @param _cmd sets command into @ref cmd_ attribute
     */
    ShellCmd(std::string _cmd);

    /**
     * Constructor with mandatory parameters.
     * @param _cmd sets command into @ref cmd_ attribute
     * @param _timeout sets maximal command lifetime into @ref timeout_ attribute
     */
    ShellCmd(std::string _cmd,
             RelativeTimeInSeconds _timeout
            );

    /**
     * Constructor with all parameters.
     * @param _cmd sets command into @ref cmd_ attribute
     * @param _shell sets shell into @ref shell_ attribute
     * @param _timeout sets maximal command lifetime into @ref timeout_ attribute
     */
    ShellCmd(std::string _cmd,
             std::string _shell,
             RelativeTimeInSeconds _timeout
            );

    /**
     * @note Kills child process if one is already alive
     */
    ~ShellCmd();

    /**
     * Execute command in shell.
     * @param stdin_str data delivered to @ref cmd_ via standard input
     * @return command outputs and exit status
     * @note Sets and restores SIGCHLD handler
     * 
     * Run <em>echo $stdin_str|$shell_ -c "$cmd_"</em>
     */
    SubProcessOutput execute(std::string stdin_str = std::string());

private:
    const std::string cmd_; /**< Command executed by @ref shell_. */
    const std::string shell_; /**< Shell executes command @ref cmd_. */
    const RelativeTimeInSeconds timeout_; /**< Maximal command lifetime in seconds. */
};//class ShellCmd

#endif
