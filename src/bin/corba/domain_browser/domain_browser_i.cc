/*
 * Copyright (C) 2014-2019  CZ.NIC, z. s. p. o.
 *
 * This file is part of FRED.
 *
 * FRED is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * FRED is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with FRED.  If not, see <https://www.gnu.org/licenses/>.
 */
/**
 *  @domain_browser_i.cc
 *  implementation of domain browser interface
 *  pregenerated by $> omniidl -bcxx -Wba -Wbexample -C./src/bin/corba ~/workspace/enum/idl/idl/DomainBrowser.idl
 */

#include "src/bin/corba/domain_browser/domain_browser_i.hh"
#include "src/backend/domain_browser/domain_browser.hh"
#include "src/bin/corba/DomainBrowser.hh"
#include "src/bin/corba/util/corba_conversions_isodate.hh"
#include "src/bin/corba/util/corba_conversions_isodatetime.hh"
#include "src/bin/corba/util/corba_conversions_nullableisodate.hh"
#include "src/bin/corba/util/corba_conversions_nullableisodatetime.hh"
#include "src/bin/corba/util/corba_conversions_nullable_types.hh"
#include "src/bin/corba/util/corba_conversions_string.hh"

#include <boost/date_time/gregorian/gregorian.hpp>

#include <string>

namespace CorbaConversion {
namespace DomainBrowser {


Server_i::Server_i(
        const std::string& _server_name,
        const std::string& _update_registrar_handle,
        unsigned int _domain_list_limit,
        unsigned int _nsset_list_limit,
        unsigned int _keyset_list_limit,
        unsigned int _contact_list_limit)
    : pimpl_(new Fred::Backend::DomainBrowser::DomainBrowser(_server_name,
              _update_registrar_handle,
              _domain_list_limit,
              _nsset_list_limit,
              _keyset_list_limit,
              _contact_list_limit))
{
}


Server_i::~Server_i()
{
}


//   Methods corresponding to IDL attributes and operations
CORBA::ULongLong Server_i::getContactId(const char* handle)
{
    try
    {
        unsigned long long id =
                pimpl_->getContactId(LibFred::Corba::unwrap_string_from_const_char_ptr(handle));
        return id;
    } // try
    catch (const Fred::Backend::DomainBrowser::ObjectNotExists&)
    {
        throw Registry::DomainBrowser::OBJECT_NOT_EXISTS();
    }
    catch (...)
    {
        throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
    }
}


Nullable<Registry::DomainBrowser::NextDomainState> corba_wrap_nullable_next_domain_state(
        const Nullable<Fred::Backend::DomainBrowser::NextDomainState>& in)
{
    if (in.isnull())
    {
        return Nullable<Registry::DomainBrowser::NextDomainState>();
    }

    Registry::DomainBrowser::NextDomainState ret;
    Fred::Backend::DomainBrowser::NextDomainState next_state = in.get_value();

    ret.state_code = LibFred::Corba::wrap_string_to_corba_string(next_state.state_code);
    ret.state_date = Util::wrap_boost_gregorian_date_to_IsoDate(next_state.state_date);
    return Nullable<Registry::DomainBrowser::NextDomainState>(ret);
}


Registry::DomainBrowser::DomainList_var corba_wrap_domain_list(
        const std::vector<Fred::Backend::DomainBrowser::DomainListData>& domain_list)
{
    Registry::DomainBrowser::DomainList_var dl = new Registry::DomainBrowser::DomainList;
    dl->length(domain_list.size());
    for (unsigned long long i = 0; i < domain_list.size(); ++i)
    {
        Registry::DomainBrowser::DomainListData dld;
        dld.id = domain_list.at(i).id;
        dld.fqdn = LibFred::Corba::wrap_string_to_corba_string(domain_list.at(i).fqdn);
        dld.external_importance = domain_list.at(i).external_importance;

        Registry::DomainBrowser::NextDomainState corba_next_domain_state;

        dld.next_state =
                Util::wrap_nullable_corba_type_to_corba_valuetype<Registry::DomainBrowser::NullableNextDomainState>(
                        corba_wrap_nullable_next_domain_state(
                                domain_list.at(i).next_state));

        dld.have_keyset = domain_list.at(i).have_keyset;
        dld.user_role = LibFred::Corba::wrap_string_to_corba_string(domain_list.at(i).user_role);
        dld.registrar_handle =
                LibFred::Corba::wrap_string_to_corba_string(domain_list.at(i).registrar_handle);
        dld.registrar_name = LibFred::Corba::wrap_string_to_corba_string(domain_list.at(i).registrar_name);

        dld.state_code.length(domain_list.at(i).state_code.size());
        for (unsigned long long j = 0; j < domain_list.at(i).state_code.size(); ++j)
        {
            dld.state_code[j] =
                    LibFred::Corba::wrap_string_to_corba_string(domain_list.at(i).state_code.at(j));
        }

        dld.is_server_blocked = domain_list.at(i).is_server_blocked;

        dl[i] = dld;
    }
    return dl;
}


Registry::DomainBrowser::DomainList* Server_i::getDomainList(
        CORBA::ULongLong user_contact_id,
        Registry::DomainBrowser::NullableULongLong* contact_id_ptr,
        CORBA::ULong offset,
        CORBA::Boolean& limit_exceeded)
{
    try
    {
        Fred::Backend::DomainBrowser::DomainList dl = pimpl_->getDomainList(
                user_contact_id,
                (contact_id_ptr) ? Optional<unsigned long long>(
                                           contact_id_ptr->_value())
                                 : Optional<unsigned long long>(),
                Optional<unsigned long long>(),
                Optional<unsigned long long>(),
                offset);
        limit_exceeded = dl.limit_exceeded;
        return corba_wrap_domain_list(dl.dld)._retn();
    }
    catch (const Fred::Backend::DomainBrowser::ObjectNotExists&)
    {
        throw Registry::DomainBrowser::OBJECT_NOT_EXISTS();
    }
    catch (const Fred::Backend::DomainBrowser::UserNotExists&)
    {
        throw Registry::DomainBrowser::USER_NOT_EXISTS();
    }
    catch (...)
    {
        throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
    }
}


Registry::DomainBrowser::NssetList_var corba_wrap_nsset_list(
        const std::vector<Fred::Backend::DomainBrowser::NssetListData>& nsset_list)
{
    Registry::DomainBrowser::NssetList_var nl = new Registry::DomainBrowser::NssetList;
    nl->length(nsset_list.size());

    for (unsigned long long i = 0; i < nsset_list.size(); ++i)
    {
        Registry::DomainBrowser::NssetListData nld;
        nld.id = nsset_list.at(i).id;
        nld.handle = LibFred::Corba::wrap_string_to_corba_string(nsset_list.at(i).handle);
        nld.domain_count = nsset_list.at(i).domain_count;
        nld.registrar_handle = LibFred::Corba::wrap_string_to_corba_string(nsset_list.at(i).registrar_handle);
        nld.registrar_name = LibFred::Corba::wrap_string_to_corba_string(nsset_list.at(i).registrar_name);
        nld.external_importance = nsset_list.at(i).external_importance;
        nld.state_code.length(nsset_list.at(i).state_code.size());
        for (unsigned long long j = 0; j < nsset_list.at(i).state_code.size(); ++j)
        {
            nld.state_code[j] =
                    LibFred::Corba::wrap_string_to_corba_string(nsset_list.at(i).state_code.at(j));
        }
        nld.is_server_blocked = nsset_list.at(i).is_server_blocked;
        nl[i] = nld;
    }

    return nl;
}


Registry::DomainBrowser::NssetList* Server_i::getNssetList(
        CORBA::ULongLong user_contact_id,
        Registry::DomainBrowser::NullableULongLong* contact_id_ptr,
        CORBA::ULong offset,
        CORBA::Boolean& limit_exceeded)
{
    try
    {
        Fred::Backend::DomainBrowser::NssetList nl = pimpl_->getNssetList(
                user_contact_id,
                (contact_id_ptr) ? Optional<unsigned long long>(
                                           contact_id_ptr->_value())
                                 : Optional<unsigned long long>(),
                offset);
        limit_exceeded = nl.limit_exceeded;
        return corba_wrap_nsset_list(nl.nld)._retn();
    }
    catch (const Fred::Backend::DomainBrowser::ObjectNotExists&)
    {
        throw Registry::DomainBrowser::OBJECT_NOT_EXISTS();
    }
    catch (const Fred::Backend::DomainBrowser::UserNotExists&)
    {
        throw Registry::DomainBrowser::USER_NOT_EXISTS();
    }
    catch (...)
    {
        throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
    }
}


Registry::DomainBrowser::KeysetList_var corba_wrap_keyset_list(
        const std::vector<Fred::Backend::DomainBrowser::KeysetListData>& keyset_list)
{
    Registry::DomainBrowser::KeysetList_var kl = new Registry::DomainBrowser::KeysetList;
    kl->length(keyset_list.size());

    for (unsigned long long i = 0; i < keyset_list.size(); ++i)
    {
        Registry::DomainBrowser::KeysetListData kld;
        kld.id = keyset_list.at(i).id;
        kld.handle = LibFred::Corba::wrap_string_to_corba_string(keyset_list.at(i).handle);
        kld.domain_count = keyset_list.at(i).domain_count;
        kld.registrar_handle =
                LibFred::Corba::wrap_string_to_corba_string(keyset_list.at(i).registrar_handle);
        kld.registrar_name = LibFred::Corba::wrap_string_to_corba_string(keyset_list.at(i).registrar_name);
        kld.external_importance = keyset_list.at(i).external_importance;
        kld.state_code.length(keyset_list.at(i).state_code.size());
        for (unsigned long long j = 0; j < keyset_list.at(i).state_code.size(); ++j)
        {
            kld.state_code[j] =
                    LibFred::Corba::wrap_string_to_corba_string(keyset_list.at(i).state_code.at(j));
        }
        kld.is_server_blocked = keyset_list.at(i).is_server_blocked;
        kl[i] = kld;
    }

    return kl;
}


Registry::DomainBrowser::KeysetList* Server_i::getKeysetList(
        CORBA::ULongLong user_contact_id,
        Registry::DomainBrowser::NullableULongLong* contact_id_ptr,
        CORBA::ULong offset,
        CORBA::Boolean& limit_exceeded)
{
    try
    {
        Fred::Backend::DomainBrowser::KeysetList kl = pimpl_->getKeysetList(
                user_contact_id,
                (contact_id_ptr) ? Optional<unsigned long long>(
                                           contact_id_ptr->_value())
                                 : Optional<unsigned long long>(),
                offset);
        limit_exceeded = kl.limit_exceeded;
        return corba_wrap_keyset_list(kl.kld)._retn();
    }
    catch (const Fred::Backend::DomainBrowser::ObjectNotExists&)
    {
        throw Registry::DomainBrowser::OBJECT_NOT_EXISTS();
    }
    catch (const Fred::Backend::DomainBrowser::UserNotExists&)
    {
        throw Registry::DomainBrowser::USER_NOT_EXISTS();
    }
    catch (...)
    {
        throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
    }
}


Registry::DomainBrowser::DomainList* Server_i::getDomainsForKeyset(
        CORBA::ULongLong user_contact_id,
        CORBA::ULongLong keyset_id,
        CORBA::ULong offset,
        CORBA::Boolean& limit_exceeded)
{
    try
    {
        Fred::Backend::DomainBrowser::DomainList dl = pimpl_->getDomainList(
                user_contact_id,
                Optional<unsigned long long>(),
                Optional<unsigned long long>(),
                Optional<unsigned long long>(keyset_id),
                offset);
        limit_exceeded = dl.limit_exceeded;
        return corba_wrap_domain_list(dl.dld)._retn();
    }
    catch (const Fred::Backend::DomainBrowser::AccessDenied&)
    {
        throw Registry::DomainBrowser::ACCESS_DENIED();
    }
    catch (const Fred::Backend::DomainBrowser::UserNotExists&)
    {
        throw Registry::DomainBrowser::USER_NOT_EXISTS();
    }
    catch (...)
    {
        throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
    }
}


Registry::DomainBrowser::DomainList* Server_i::getDomainsForNsset(
        CORBA::ULongLong user_contact_id,
        CORBA::ULongLong nsset_id,
        CORBA::ULong offset,
        CORBA::Boolean& limit_exceeded)
{
    try
    {
        Fred::Backend::DomainBrowser::DomainList dl = pimpl_->getDomainList(
                user_contact_id,
                Optional<unsigned long long>(),
                Optional<unsigned long long>(nsset_id),
                Optional<unsigned long long>(),
                offset);
        limit_exceeded = dl.limit_exceeded;
        return corba_wrap_domain_list(dl.dld)._retn();
    }
    catch (const Fred::Backend::DomainBrowser::AccessDenied&)
    {
        throw Registry::DomainBrowser::ACCESS_DENIED();
    }
    catch (const Fred::Backend::DomainBrowser::UserNotExists&)
    {
        throw Registry::DomainBrowser::USER_NOT_EXISTS();
    }
    catch (...)
    {
        throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
    }
}


Nullable<Registry::DomainBrowser::PlaceAddress> corba_wrap_nullable_placeaddress(
        const Nullable<LibFred::Contact::PlaceAddress>& in)
{
    if (in.isnull())
    {
        return Nullable<Registry::DomainBrowser::PlaceAddress>();
    }

    Registry::DomainBrowser::PlaceAddress ret;
    LibFred::Contact::PlaceAddress mailing_addr = in.get_value();

    ret.street1 = LibFred::Corba::wrap_string_to_corba_string(mailing_addr.street1);
    ret.street2 = Util::wrap_nullable_corba_type_to_corba_valuetype<Registry::DomainBrowser::NullableString>(
            LibFred::Corba::wrap_optional_string_to_nullable_corba_string(mailing_addr.street2));
    ret.street3 = Util::wrap_nullable_corba_type_to_corba_valuetype<Registry::DomainBrowser::NullableString>(
            LibFred::Corba::wrap_optional_string_to_nullable_corba_string(mailing_addr.street3));
    ret.state = Util::wrap_nullable_corba_type_to_corba_valuetype<Registry::DomainBrowser::NullableString>(
            LibFred::Corba::wrap_optional_string_to_nullable_corba_string(mailing_addr.stateorprovince));
    ret.postal_code = LibFred::Corba::wrap_string_to_corba_string(mailing_addr.postalcode);
    ret.city = LibFred::Corba::wrap_string_to_corba_string(mailing_addr.city);
    ret.country = LibFred::Corba::wrap_string_to_corba_string(mailing_addr.country);

    return Nullable<Registry::DomainBrowser::PlaceAddress>(ret);
}


Registry::DomainBrowser::ContactDetail* Server_i::getContactDetail(
        CORBA::ULongLong user_contact_id,
        CORBA::ULongLong detail_id,
        Registry::DomainBrowser::DataAccessLevel& auth_result)
{
    try
    {
        Fred::Backend::DomainBrowser::ContactDetail detail_impl = pimpl_->getContactDetail(
                user_contact_id,
                detail_id);

        Registry::DomainBrowser::ContactDetail_var contact_detail =
                new Registry::DomainBrowser::ContactDetail;
        contact_detail->id = detail_impl.id;
        contact_detail->handle = LibFred::Corba::wrap_string_to_corba_string(detail_impl.handle);
        contact_detail->roid = LibFred::Corba::wrap_string_to_corba_string(detail_impl.roid);
        contact_detail->registrar.id = detail_impl.sponsoring_registrar.id;
        contact_detail->registrar.handle = LibFred::Corba::wrap_string_to_corba_string(
                detail_impl.sponsoring_registrar.handle);
        contact_detail->registrar.name = LibFred::Corba::wrap_string_to_corba_string(
                detail_impl.sponsoring_registrar.name);
        contact_detail->create_time = CorbaConversion::Util::wrap_boost_posix_time_ptime_to_IsoDateTime(
                detail_impl.creation_time);

        contact_detail->transfer_time =
                CorbaConversion::Util::wrap_Nullable_boost_posix_time_ptime_to_NullableIsoDateTime(
                        detail_impl.transfer_time);
        contact_detail->update_time =
                CorbaConversion::Util::wrap_Nullable_boost_posix_time_ptime_to_NullableIsoDateTime(
                        detail_impl.update_time);

        contact_detail->auth_info = LibFred::Corba::wrap_string_to_corba_string(detail_impl.authinfopw);
        contact_detail->name = LibFred::Corba::wrap_string_to_corba_string(
                detail_impl.name.get_value_or_default());
        contact_detail->organization = LibFred::Corba::wrap_string_to_corba_string(
                detail_impl.organization.get_value_or_default());

        contact_detail->permanent_address.street1 = LibFred::Corba::wrap_string_to_corba_string(
                detail_impl.permanent_address.street1);
        contact_detail->permanent_address.street2 =
                Util::wrap_nullable_corba_type_to_corba_valuetype<Registry::DomainBrowser::NullableString>(
                        LibFred::Corba::wrap_optional_string_to_nullable_corba_string(detail_impl.permanent_address.street2));
        contact_detail->permanent_address.street3 =
                Util::wrap_nullable_corba_type_to_corba_valuetype<Registry::DomainBrowser::NullableString>(
                        LibFred::Corba::wrap_optional_string_to_nullable_corba_string(detail_impl.permanent_address.street3));
        contact_detail->permanent_address.state =
                Util::wrap_nullable_corba_type_to_corba_valuetype<Registry::DomainBrowser::NullableString>(
                        LibFred::Corba::wrap_optional_string_to_nullable_corba_string(detail_impl.permanent_address.stateorprovince));
        contact_detail->permanent_address.postal_code = LibFred::Corba::wrap_string_to_corba_string(
                detail_impl.permanent_address.postalcode);
        contact_detail->permanent_address.city = LibFred::Corba::wrap_string_to_corba_string(
                detail_impl.permanent_address.city);
        contact_detail->permanent_address.country = LibFred::Corba::wrap_string_to_corba_string(
                detail_impl.permanent_address.country);

        contact_detail->mailing_address =
                Util::wrap_nullable_corba_type_to_corba_valuetype<Registry::DomainBrowser::NullablePlaceAddress>(
                        corba_wrap_nullable_placeaddress(detail_impl.mailing_address));

        contact_detail->telephone = LibFred::Corba::wrap_string_to_corba_string(
                detail_impl.telephone.get_value_or_default());
        contact_detail->fax = LibFred::Corba::wrap_string_to_corba_string(
                detail_impl.fax.get_value_or_default());
        contact_detail->email = LibFred::Corba::wrap_string_to_corba_string(
                detail_impl.email.get_value_or_default());
        contact_detail->notify_email = LibFred::Corba::wrap_string_to_corba_string(
                detail_impl.notifyemail.get_value_or_default());
        contact_detail->ssn = LibFred::Corba::wrap_string_to_corba_string(
                detail_impl.ssn.get_value_or_default());
        contact_detail->ssn_type = LibFred::Corba::wrap_string_to_corba_string(
                detail_impl.ssntype.get_value_or_default());
        contact_detail->vat = LibFred::Corba::wrap_string_to_corba_string(
                detail_impl.vat.get_value_or_default());
        contact_detail->disclose_flags.address = detail_impl.disclose_flags.address;
        contact_detail->disclose_flags.email = detail_impl.disclose_flags.email;
        contact_detail->disclose_flags.fax = detail_impl.disclose_flags.fax;
        contact_detail->disclose_flags.ident = detail_impl.disclose_flags.ident;
        contact_detail->disclose_flags.name = detail_impl.disclose_flags.name;
        contact_detail->disclose_flags.notify_email = detail_impl.disclose_flags.notify_email;
        contact_detail->disclose_flags.organization = detail_impl.disclose_flags.organization;
        contact_detail->disclose_flags.telephone = detail_impl.disclose_flags.telephone;
        contact_detail->disclose_flags.vat = detail_impl.disclose_flags.vat;

        contact_detail->state_codes.length(detail_impl.state_codes.size());
        for (unsigned long long j = 0; j < detail_impl.state_codes.size(); ++j)
        {
            contact_detail->state_codes[j] = LibFred::Corba::wrap_string_to_corba_string(
                    detail_impl.state_codes.at(j));
        }

        if (detail_impl.is_owner)
        {
            auth_result = Registry::DomainBrowser::PRIVATE_DATA;
        }
        else
        {
            auth_result = Registry::DomainBrowser::PUBLIC_DATA;
        }

        contact_detail->warning_letter =
                Util::wrap_nullable_corba_type_to_corba_valuetype<Registry::DomainBrowser::NullableBoolean>(
                        detail_impl.warning_letter);

        return contact_detail._retn();
    }
    catch (const Fred::Backend::DomainBrowser::ObjectNotExists&)
    {
        throw Registry::DomainBrowser::OBJECT_NOT_EXISTS();
    }
    catch (const Fred::Backend::DomainBrowser::UserNotExists&)
    {
        throw Registry::DomainBrowser::USER_NOT_EXISTS();
    }
    catch (...)
    {
        throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
    }
}


Registry::DomainBrowser::NSSetDetail* Server_i::getNssetDetail(
        CORBA::ULongLong user_contact_id,
        CORBA::ULongLong nsset_id,
        Registry::DomainBrowser::DataAccessLevel& auth_result)
{
    try
    {
        Fred::Backend::DomainBrowser::NssetDetail detail_impl = pimpl_->getNssetDetail(
                user_contact_id,
                nsset_id);

        Registry::DomainBrowser::NSSetDetail_var nsset_detail = new Registry::DomainBrowser::NSSetDetail;

        nsset_detail->id = detail_impl.id;
        nsset_detail->handle = LibFred::Corba::wrap_string_to_corba_string(detail_impl.handle);
        nsset_detail->roid = LibFred::Corba::wrap_string_to_corba_string(detail_impl.roid);
        nsset_detail->registrar.id = detail_impl.sponsoring_registrar.id;
        nsset_detail->registrar.handle = LibFred::Corba::wrap_string_to_corba_string(
                detail_impl.sponsoring_registrar.handle);
        nsset_detail->registrar.name = LibFred::Corba::wrap_string_to_corba_string(
                detail_impl.sponsoring_registrar.name);
        nsset_detail->create_time = CorbaConversion::Util::wrap_boost_posix_time_ptime_to_IsoDateTime(
                detail_impl.creation_time);

        nsset_detail->transfer_time =
                CorbaConversion::Util::wrap_Nullable_boost_posix_time_ptime_to_NullableIsoDateTime(
                        detail_impl.transfer_time);
        nsset_detail->update_time =
                CorbaConversion::Util::wrap_Nullable_boost_posix_time_ptime_to_NullableIsoDateTime(
                        detail_impl.update_time);

        nsset_detail->create_registrar.id = detail_impl.create_registrar.id;
        nsset_detail->create_registrar.handle = LibFred::Corba::wrap_string_to_corba_string(
                detail_impl.create_registrar.handle);
        nsset_detail->create_registrar.name = LibFred::Corba::wrap_string_to_corba_string(
                detail_impl.create_registrar.name);

        nsset_detail->update_registrar.id = detail_impl.update_registrar.id;
        nsset_detail->update_registrar.handle = LibFred::Corba::wrap_string_to_corba_string(
                detail_impl.update_registrar.handle);
        nsset_detail->update_registrar.name = LibFred::Corba::wrap_string_to_corba_string(
                detail_impl.update_registrar.name);

        nsset_detail->auth_info = LibFred::Corba::wrap_string_to_corba_string(detail_impl.authinfopw);

        nsset_detail->admins.length(detail_impl.admins.size());
        for (std::size_t i = 0; i < detail_impl.admins.size(); ++i)
        {
            nsset_detail->admins[i].id = detail_impl.admins[i].id;
            nsset_detail->admins[i].handle = LibFred::Corba::wrap_string_to_corba_string(
                    detail_impl.admins[i].handle);
            nsset_detail->admins[i].name = LibFred::Corba::wrap_string_to_corba_string(
                    detail_impl.admins[i].name);
        }

        nsset_detail->hosts.length(detail_impl.hosts.size());
        for (std::size_t i = 0; i < detail_impl.hosts.size(); ++i)
        {
            nsset_detail->hosts[i].fqdn = LibFred::Corba::wrap_string_to_corba_string(
                    detail_impl.hosts[i].get_fqdn());

            std::vector<boost::asio::ip::address> inet_addrs = detail_impl.hosts[i].get_inet_addr();
            nsset_detail->hosts[i].inet.length(inet_addrs.size());
            for (std::size_t j = 0; j < inet_addrs.size(); ++j)
            {
                nsset_detail->hosts[i].inet[j] = LibFred::Corba::wrap_string_to_corba_string(
                        inet_addrs.at(j).to_string());
            }
        }

        nsset_detail->state_codes.length(detail_impl.state_codes.size());
        for (unsigned long long j = 0; j < detail_impl.state_codes.size(); ++j)
        {
            nsset_detail->state_codes[j] = LibFred::Corba::wrap_string_to_corba_string(
                    detail_impl.state_codes.at(j));
        }

        nsset_detail->report_level = detail_impl.report_level;

        if (detail_impl.is_owner)
        {
            auth_result = Registry::DomainBrowser::PRIVATE_DATA;
        }
        else
        {
            auth_result = Registry::DomainBrowser::PUBLIC_DATA;
        }

        return nsset_detail._retn();
    }
    catch (const Fred::Backend::DomainBrowser::ObjectNotExists&)
    {
        throw Registry::DomainBrowser::OBJECT_NOT_EXISTS();
    }
    catch (const Fred::Backend::DomainBrowser::UserNotExists&)
    {
        throw Registry::DomainBrowser::USER_NOT_EXISTS();
    }
    catch (...)
    {
        throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
    }
}


Registry::DomainBrowser::DomainDetail* Server_i::getDomainDetail(
        CORBA::ULongLong user_contact_id,
        CORBA::ULongLong domain_id,
        Registry::DomainBrowser::DataAccessLevel& auth_result)
{
    try
    {
        Fred::Backend::DomainBrowser::DomainDetail detail_impl = pimpl_->getDomainDetail(
                user_contact_id,
                domain_id);

        Registry::DomainBrowser::DomainDetail_var domain_detail = new Registry::DomainBrowser::DomainDetail;
        domain_detail->id = detail_impl.id;
        domain_detail->fqdn = LibFred::Corba::wrap_string_to_corba_string(detail_impl.fqdn);
        domain_detail->roid = LibFred::Corba::wrap_string_to_corba_string(detail_impl.roid);
        domain_detail->registrar.id = detail_impl.sponsoring_registrar.id;
        domain_detail->registrar.handle = LibFred::Corba::wrap_string_to_corba_string(
                detail_impl.sponsoring_registrar.handle);
        domain_detail->registrar.name = LibFred::Corba::wrap_string_to_corba_string(
                detail_impl.sponsoring_registrar.name);
        domain_detail->create_time = CorbaConversion::Util::wrap_boost_posix_time_ptime_to_IsoDateTime(
                detail_impl.creation_time);

        domain_detail->update_time =
                CorbaConversion::Util::wrap_Nullable_boost_posix_time_ptime_to_NullableIsoDateTime(
                        detail_impl.update_time);

        domain_detail->auth_info = LibFred::Corba::wrap_string_to_corba_string(detail_impl.authinfopw);
        domain_detail->registrant.id = detail_impl.registrant.id;
        domain_detail->registrant.handle = LibFred::Corba::wrap_string_to_corba_string(
                detail_impl.registrant.handle);
        domain_detail->registrant.name = LibFred::Corba::wrap_string_to_corba_string(
                detail_impl.registrant.name);

        domain_detail->expiration_date = CorbaConversion::Util::wrap_boost_gregorian_date_to_IsoDate(
                detail_impl.expiration_date);

        domain_detail->is_enum = !detail_impl.enum_domain_validation.isnull();
        if (domain_detail->is_enum)
        {
            domain_detail->publish = detail_impl.enum_domain_validation.get_value().publish;

            domain_detail->val_ex_date =
                    CorbaConversion::Util::wrap_Nullable_boost_gregorian_date_to_NullableIsoDate(
                            Nullable<boost::gregorian::date>(detail_impl.enum_domain_validation.get_value().validation_expiration));
        }
        else
        {
            domain_detail->publish = false;
            domain_detail->val_ex_date = 0;
        }

        domain_detail->nsset.id = detail_impl.nsset.id;
        domain_detail->nsset.handle = LibFred::Corba::wrap_string_to_corba_string(detail_impl.nsset.handle);
        domain_detail->nsset.name = LibFred::Corba::wrap_string_to_corba_string(detail_impl.nsset.name);

        domain_detail->keyset.id = detail_impl.keyset.id;
        domain_detail->keyset.handle = LibFred::Corba::wrap_string_to_corba_string(detail_impl.keyset.handle);
        domain_detail->keyset.name = LibFred::Corba::wrap_string_to_corba_string(detail_impl.keyset.name);

        domain_detail->admins.length(detail_impl.admins.size());

        for (std::size_t i = 0; i < detail_impl.admins.size(); ++i)
        {
            domain_detail->admins[i].id = detail_impl.admins[i].id;
            domain_detail->admins[i].handle = LibFred::Corba::wrap_string_to_corba_string(
                    detail_impl.admins[i].handle);
            domain_detail->admins[i].name = LibFred::Corba::wrap_string_to_corba_string(
                    detail_impl.admins[i].name);
        }

        domain_detail->state_codes.length(detail_impl.state_codes.size());
        for (unsigned long long j = 0; j < detail_impl.state_codes.size(); ++j)
        {
            domain_detail->state_codes[j] = LibFred::Corba::wrap_string_to_corba_string(
                    detail_impl.state_codes.at(j));
        }

        if (detail_impl.is_owner || detail_impl.is_admin)
        {
            auth_result = Registry::DomainBrowser::PRIVATE_DATA;
        }
        else
        {
            auth_result = Registry::DomainBrowser::PUBLIC_DATA;
        }

        return domain_detail._retn();
    }
    catch (const Fred::Backend::DomainBrowser::ObjectNotExists&)
    {
        throw Registry::DomainBrowser::OBJECT_NOT_EXISTS();
    }
    catch (const Fred::Backend::DomainBrowser::UserNotExists&)
    {
        throw Registry::DomainBrowser::USER_NOT_EXISTS();
    }
    catch (...)
    {
        throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
    }
}


Registry::DomainBrowser::KeysetDetail* Server_i::getKeysetDetail(
        CORBA::ULongLong user_contact_id,
        CORBA::ULongLong keyset_id,
        Registry::DomainBrowser::DataAccessLevel& auth_result)
{
    try
    {
        Fred::Backend::DomainBrowser::KeysetDetail detail_impl = pimpl_->getKeysetDetail(
                user_contact_id,
                keyset_id);

        Registry::DomainBrowser::KeysetDetail_var keyset_detail = new Registry::DomainBrowser::KeysetDetail;

        keyset_detail->id = detail_impl.id;
        keyset_detail->handle = LibFred::Corba::wrap_string_to_corba_string(detail_impl.handle);
        keyset_detail->roid = LibFred::Corba::wrap_string_to_corba_string(detail_impl.roid);
        keyset_detail->registrar.id = detail_impl.sponsoring_registrar.id;
        keyset_detail->registrar.handle = LibFred::Corba::wrap_string_to_corba_string(
                detail_impl.sponsoring_registrar.handle);
        keyset_detail->registrar.name = LibFred::Corba::wrap_string_to_corba_string(
                detail_impl.sponsoring_registrar.name);
        keyset_detail->create_time = CorbaConversion::Util::wrap_boost_posix_time_ptime_to_IsoDateTime(
                detail_impl.creation_time);

        keyset_detail->transfer_time =
                CorbaConversion::Util::wrap_Nullable_boost_posix_time_ptime_to_NullableIsoDateTime(
                        detail_impl.transfer_time);
        keyset_detail->update_time =
                CorbaConversion::Util::wrap_Nullable_boost_posix_time_ptime_to_NullableIsoDateTime(
                        detail_impl.update_time);

        keyset_detail->create_registrar.id = detail_impl.create_registrar.id;
        keyset_detail->create_registrar.handle = LibFred::Corba::wrap_string_to_corba_string(
                detail_impl.create_registrar.handle);
        keyset_detail->create_registrar.name = LibFred::Corba::wrap_string_to_corba_string(
                detail_impl.create_registrar.name);

        keyset_detail->update_registrar.id = detail_impl.update_registrar.id;
        keyset_detail->update_registrar.handle = LibFred::Corba::wrap_string_to_corba_string(
                detail_impl.update_registrar.handle);
        keyset_detail->update_registrar.name = LibFred::Corba::wrap_string_to_corba_string(
                detail_impl.update_registrar.name);

        keyset_detail->auth_info = LibFred::Corba::wrap_string_to_corba_string(detail_impl.authinfopw);

        keyset_detail->admins.length(detail_impl.admins.size());
        for (std::size_t i = 0; i < detail_impl.admins.size(); ++i)
        {
            keyset_detail->admins[i].id = detail_impl.admins[i].id;
            keyset_detail->admins[i].handle = LibFred::Corba::wrap_string_to_corba_string(
                    detail_impl.admins[i].handle);
            keyset_detail->admins[i].name = LibFred::Corba::wrap_string_to_corba_string(
                    detail_impl.admins[i].name);
        }

        keyset_detail->dnskeys.length(detail_impl.dnskeys.size());
        for (std::size_t i = 0; i < detail_impl.dnskeys.size(); ++i)
        {
            keyset_detail->dnskeys[i].flags = detail_impl.dnskeys[i].flags;
            keyset_detail->dnskeys[i].protocol = detail_impl.dnskeys[i].protocol;
            keyset_detail->dnskeys[i].alg = detail_impl.dnskeys[i].alg;
            keyset_detail->dnskeys[i].key = LibFred::Corba::wrap_string_to_corba_string(
                    detail_impl.dnskeys[i].key);
        }

        keyset_detail->state_codes.length(detail_impl.state_codes.size());
        for (unsigned long long j = 0; j < detail_impl.state_codes.size(); ++j)
        {
            keyset_detail->state_codes[j] = LibFred::Corba::wrap_string_to_corba_string(
                    detail_impl.state_codes.at(j));
        }

        if (detail_impl.is_owner)
        {
            auth_result = Registry::DomainBrowser::PRIVATE_DATA;
        }
        else
        {
            auth_result = Registry::DomainBrowser::PUBLIC_DATA;
        }

        return keyset_detail._retn();
    }
    catch (const Fred::Backend::DomainBrowser::ObjectNotExists&)
    {
        throw Registry::DomainBrowser::OBJECT_NOT_EXISTS();
    }
    catch (const Fred::Backend::DomainBrowser::UserNotExists&)
    {
        throw Registry::DomainBrowser::USER_NOT_EXISTS();
    }
    catch (...)
    {
        throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
    }
}


Registry::DomainBrowser::RegistrarDetail* Server_i::getRegistrarDetail(
        CORBA::ULongLong user_contact_id,
        const char* handle)
{
    try
    {
        Fred::Backend::DomainBrowser::RegistrarDetail detail_impl = pimpl_->getRegistrarDetail(
                user_contact_id,
                handle);

        Registry::DomainBrowser::RegistrarDetail_var registrar_detail =
                new Registry::DomainBrowser::RegistrarDetail;
        registrar_detail->id = detail_impl.id;
        registrar_detail->handle = LibFred::Corba::wrap_string_to_corba_string(detail_impl.handle);
        registrar_detail->name = LibFred::Corba::wrap_string_to_corba_string(detail_impl.name);
        registrar_detail->phone = LibFred::Corba::wrap_string_to_corba_string(detail_impl.phone);
        registrar_detail->fax = LibFred::Corba::wrap_string_to_corba_string(detail_impl.fax);
        registrar_detail->url = LibFred::Corba::wrap_string_to_corba_string(detail_impl.url);
        registrar_detail->address = LibFred::Corba::wrap_string_to_corba_string(detail_impl.address);

        return registrar_detail._retn();
    }
    catch (const Fred::Backend::DomainBrowser::ObjectNotExists&)
    {
        throw Registry::DomainBrowser::OBJECT_NOT_EXISTS();
    }
    catch (const Fred::Backend::DomainBrowser::UserNotExists&)
    {
        throw Registry::DomainBrowser::USER_NOT_EXISTS();
    }
    catch (...)
    {
        throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
    }
}


CORBA::Boolean Server_i::setContactDiscloseFlags(
        CORBA::ULongLong user_contact_id,
        const Registry::DomainBrowser::UpdateContactDiscloseFlags& flags,
        CORBA::ULongLong request_id)
{
    try
    {
        Fred::Backend::DomainBrowser::ContactDiscloseFlagsToSet flags_;
        flags_.email = flags.email;
        flags_.address = flags.address;
        flags_.telephone = flags.telephone;
        flags_.fax = flags.fax;
        flags_.ident = flags.ident;
        flags_.vat = flags.vat;
        flags_.notify_email = flags.notify_email;
        return pimpl_->setContactDiscloseFlags(
                user_contact_id,
                flags_,
                request_id);
    }
    catch (const Fred::Backend::DomainBrowser::UserNotExists&)
    {
        throw Registry::DomainBrowser::USER_NOT_EXISTS();
    }
    catch (const Fred::Backend::DomainBrowser::IncorrectUsage&)
    {
        throw Registry::DomainBrowser::INCORRECT_USAGE();
    }
    catch (const Fred::Backend::DomainBrowser::ObjectBlocked&)
    {
        throw Registry::DomainBrowser::OBJECT_BLOCKED();
    }
    catch (const Fred::Backend::DomainBrowser::AccessDenied&)
    {
        throw Registry::DomainBrowser::ACCESS_DENIED();
    }
    catch (...)
    {
        throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
    }
}


CORBA::Boolean Server_i::setContactAuthInfo(
        CORBA::ULongLong user_contact_id,
        const char* auth_info,
        CORBA::ULongLong request_id)
{
    try
    {
        return pimpl_->setContactAuthInfo(
                user_contact_id,
                auth_info,
                request_id);
    }
    catch (const Fred::Backend::DomainBrowser::UserNotExists&)
    {
        throw Registry::DomainBrowser::USER_NOT_EXISTS();
    }
    catch (const Fred::Backend::DomainBrowser::IncorrectUsage&)
    {
        throw Registry::DomainBrowser::INCORRECT_USAGE();
    }
    catch (const Fred::Backend::DomainBrowser::ObjectBlocked&)
    {
        throw Registry::DomainBrowser::OBJECT_BLOCKED();
    }
    catch (const Fred::Backend::DomainBrowser::AccessDenied&)
    {
        throw Registry::DomainBrowser::ACCESS_DENIED();
    }
    catch (...)
    {
        throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
    }
}


CORBA::Boolean Server_i::setObjectBlockStatus(
        CORBA::ULongLong user_contact_id,
        const char* objtype,
        const Registry::DomainBrowser::ObjectIdSeq& objects,
        Registry::DomainBrowser::ObjectBlockType block,
        Registry::DomainBrowser::RefusedObjectHandleSequence_out change_prohibited)
{
    try
    {
        std::vector<unsigned long long> objects_id;
        objects_id.reserve(objects.length());
        for (std::size_t i = 0; i < objects.length(); ++i)
        {
            objects_id.push_back(objects[i]);
        }
        std::vector<std::string> blocked_objects;

        bool ret = pimpl_->setObjectBlockStatus(
                user_contact_id,
                objtype,
                objects_id,
                (block ==
                        Registry::DomainBrowser::BLOCK_TRANSFER)
                        ? Fred::Backend::DomainBrowser::BLOCK_TRANSFER
                        : (
                                  block ==
                                  Registry::DomainBrowser::UNBLOCK_TRANSFER)
                                  ? Fred::Backend::DomainBrowser::UNBLOCK_TRANSFER
                                  : (
                                            block ==
                                            Registry::DomainBrowser::BLOCK_TRANSFER_AND_UPDATE)
                                            ? Fred::Backend::DomainBrowser::BLOCK_TRANSFER_AND_UPDATE
                                            : (
                                                      block ==
                                                      Registry::DomainBrowser::UNBLOCK_TRANSFER_AND_UPDATE)
                                                      ? Fred::Backend::DomainBrowser::UNBLOCK_TRANSFER_AND_UPDATE
                                                      : Fred::Backend::DomainBrowser::INVALID_BLOCK_TYPE,
                blocked_objects);

        Registry::DomainBrowser::RefusedObjectHandleSequence_var change_prohibited_var =
                new Registry::DomainBrowser::RefusedObjectHandleSequence;
        change_prohibited_var->length(blocked_objects.size());
        for (std::size_t i = 0; i < blocked_objects.size(); ++i)
        {
            change_prohibited_var[i] = LibFred::Corba::wrap_string_to_corba_string(blocked_objects.at(i));
        }

        change_prohibited = change_prohibited_var._retn(); // transfer ownership to the out parameter, no exceptions allowed after this point
        return ret;
    }
    catch (const Fred::Backend::DomainBrowser::ObjectNotExists&)
    {
        throw Registry::DomainBrowser::OBJECT_NOT_EXISTS();
    }
    catch (const Fred::Backend::DomainBrowser::UserNotExists&)
    {
        throw Registry::DomainBrowser::USER_NOT_EXISTS();
    }
    catch (const Fred::Backend::DomainBrowser::IncorrectUsage&)
    {
        throw Registry::DomainBrowser::INCORRECT_USAGE();
    }
    catch (const Fred::Backend::DomainBrowser::AccessDenied&)
    {
        throw Registry::DomainBrowser::ACCESS_DENIED();
    }
    catch (...)
    {
        throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
    }
}


Registry::DomainBrowser::StatusDescList* Server_i::getPublicStatusDesc(const char* lang)
{
    try
    {
        std::vector<Fred::Backend::DomainBrowser::StatusDesc> status_description =
                pimpl_->getPublicStatusDesc(lang);
        Registry::DomainBrowser::StatusDescList_var status_description_var =
                new Registry::DomainBrowser::StatusDescList;
        status_description_var->length(status_description.size());
        for (std::size_t i = 0; i < status_description.size(); ++i)
        {
            status_description_var[i].state_code = LibFred::Corba::wrap_string_to_corba_string(
                    status_description.at(i).state_code);
            status_description_var[i].state_desc = LibFred::Corba::wrap_string_to_corba_string(
                    status_description.at(i).state_desc);
        }
        return status_description_var._retn();
    }
    catch (...)
    {
        throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
    }
}


Registry::DomainBrowser::MergeContactCandidateList_var corba_wrap_merge_contact_candidate_list(
        const std::vector<Fred::Backend::DomainBrowser::MergeContactCandidateData>& candidate_list)
{
    Registry::DomainBrowser::MergeContactCandidateList_var cl =
            new Registry::DomainBrowser::MergeContactCandidateList;
    cl->length(candidate_list.size());

    for (unsigned long long i = 0; i < candidate_list.size(); ++i)
    {
        Registry::DomainBrowser::MergeContactCandidateData cld;
        cld.id = candidate_list.at(i).id;
        cld.handle = LibFred::Corba::wrap_string_to_corba_string(candidate_list.at(i).handle);
        cld.domain_count = candidate_list.at(i).domain_count;
        cld.nsset_count = candidate_list.at(i).nsset_count;
        cld.keyset_count = candidate_list.at(i).keyset_count;
        cld.registrar_handle = LibFred::Corba::wrap_string_to_corba_string(
                candidate_list.at(i).registrar_handle);
        cld.registrar_name = LibFred::Corba::wrap_string_to_corba_string(candidate_list.at(i).registrar_name);

        cl[i] = cld;
    }

    return cl;
}


Registry::DomainBrowser::MergeContactCandidateList* Server_i::getMergeContactCandidateList(
        CORBA::ULongLong user_contact_id,
        CORBA::ULong offset,
        CORBA::Boolean& limit_exceeded)
{
    try
    {
        Fred::Backend::DomainBrowser::MergeContactCandidateList mcl = pimpl_->getMergeContactCandidateList(
                user_contact_id,
                offset);
        limit_exceeded = mcl.limit_exceeded;
        return corba_wrap_merge_contact_candidate_list(mcl.mccl)._retn();
    }
    catch (const Fred::Backend::DomainBrowser::UserNotExists&)
    {
        throw Registry::DomainBrowser::USER_NOT_EXISTS();
    }
    catch (...)
    {
        throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
    }
}


void Server_i::mergeContacts(
        CORBA::ULongLong dst_contact_id,
        const Registry::DomainBrowser::ObjectIdSeq& src_contact_id_list,
        CORBA::ULongLong request_id)
{
    try
    {
        std::vector<unsigned long long> contact_list;
        contact_list.reserve(src_contact_id_list.length());
        for (std::size_t i = 0; i < src_contact_id_list.length(); ++i)
        {
            contact_list.push_back(src_contact_id_list[i]);
        }
        pimpl_->mergeContacts(
                dst_contact_id,
                contact_list,
                request_id);
    }
    catch (const Fred::Backend::DomainBrowser::UserNotExists&)
    {
        throw Registry::DomainBrowser::USER_NOT_EXISTS();
    }
    catch (const Fred::Backend::DomainBrowser::InvalidContacts&)
    {
        throw Registry::DomainBrowser::INVALID_CONTACTS();
    }
    catch (...)
    {
        throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
    }
}


void Server_i::setContactPreferenceForDomainExpirationLetters(
        CORBA::ULongLong user_contact_id,
        CORBA::Boolean send_expiration_letters,
        CORBA::ULongLong request_id)
{
    try
    {
        return pimpl_->setContactPreferenceForDomainExpirationLetters(
                user_contact_id,
                send_expiration_letters,
                request_id);
    }
    catch (const Fred::Backend::DomainBrowser::UserNotExists&)
    {
        throw Registry::DomainBrowser::USER_NOT_EXISTS();
    }
    catch (const Fred::Backend::DomainBrowser::ObjectBlocked&)
    {
        throw Registry::DomainBrowser::OBJECT_BLOCKED();
    }
    catch (const Fred::Backend::DomainBrowser::AccessDenied&)
    {
        throw Registry::DomainBrowser::ACCESS_DENIED();
    }
    catch (...)
    {
        throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
    }
}

} // namespace CorbaConversion::DomainBrowser
} // namespace CorbaConversion
