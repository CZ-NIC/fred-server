/*
 * Copyright (C) 2013  CZ.NIC, z.s.p.o.
 *
 * This file is part of FRED.
 *
 * FRED is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * FRED is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with FRED.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 *  @domain_browser_i.cc
 *  implementation of domain browser interface
 *  pregenerated by $> omniidl -bcxx -Wba -Wbexample -C./src/corba ~/workspace/enum/idl/idl/DomainBrowser.idl
 */

#include "domain_browser_i.h"
#include "src/domain_browser/domain_browser.h"
#include "src/corba/DomainBrowser.hh"
#include <string>


namespace Registry
{
    namespace DomainBrowser
    {

        Server_i::Server_i(const std::string &_server_name)
        : pimpl_(new Registry::DomainBrowserImpl::DomainBrowser(_server_name))
        {}

        Server_i::~Server_i()
        {}

        //   Methods corresponding to IDL attributes and operations
        Registry::DomainBrowser::TID Server_i::getObjectRegistryId(
            const char* objtype,
            const char* handle)
        {
            try
            {
                unsigned long long id = pimpl_->getObjectRegistryId(objtype,handle);
                return id;
            }//try
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::OBJECT_NOT_EXISTS();
            }
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::INCORRECT_USAGE();
            }
            catch (...)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }
        }

        Registry::DomainBrowser::RecordSet* Server_i::getDomainList(
            const Registry::DomainBrowser::RegistryReference& contact,
            const char* lang,
            ::CORBA::ULong offset,
             ::CORBA::Boolean& limit_exceeded)
        {
            try
            {
                RecordSet_var rs = new RecordSet;
                rs->length(1);

                RecordSequence_var rseq = new RecordSequence;
                rseq->length(1);

                RegistryObject_var robject = CORBA::string_dup("test_object");

                rseq[0] = robject._retn();

                rs[0] = rseq;

                return rs._retn();
            }//try
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::USER_NOT_EXISTS();
            }
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::INCORRECT_USAGE();
            }
            catch (...)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }
        }

        Registry::DomainBrowser::RecordSet* Server_i::getNssetList(
            const Registry::DomainBrowser::RegistryReference& contact,
            const char* lang,
            ::CORBA::ULong offset,
             ::CORBA::Boolean& limit_exceeded)
        {
            try
            {
                RecordSet_var rs = new RecordSet;
                rs->length(1);

                RecordSequence_var rseq = new RecordSequence;
                rseq->length(1);

                RegistryObject_var robject = CORBA::string_dup("test_object");

                rseq[0] = robject._retn();

                rs[0] = rseq;

                return rs._retn();
            }//try
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::USER_NOT_EXISTS();
            }
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::INCORRECT_USAGE();
            }
            catch (...)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }
        }

        Registry::DomainBrowser::RecordSet* Server_i::getKeysetList(
            const Registry::DomainBrowser::RegistryReference& contact,
            const char* lang,
            ::CORBA::ULong offset,
             ::CORBA::Boolean& limit_exceeded)
        {
            try
            {
                RecordSet_var rs = new RecordSet;
                rs->length(1);

                RecordSequence_var rseq = new RecordSequence;
                rseq->length(1);

                RegistryObject_var robject = CORBA::string_dup("test_object");

                rseq[0] = robject._retn();

                rs[0] = rseq;

                return rs._retn();
            }//try
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::USER_NOT_EXISTS();
            }
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::INCORRECT_USAGE();
            }
            catch (...)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }
        }

        Registry::DomainBrowser::RecordSet* Server_i::getDomainsForKeyset(
            const Registry::DomainBrowser::RegistryReference& contact,
            const Registry::DomainBrowser::RegistryReference& keyset,
            const char* lang,
            ::CORBA::ULong offset,
            ::CORBA::Boolean& limit_exceeded)
        {
            try
            {
                RecordSet_var rs = new RecordSet;
                rs->length(1);

                RecordSequence_var rseq = new RecordSequence;
                rseq->length(1);

                RegistryObject_var robject = CORBA::string_dup("test_object");

                rseq[0] = robject._retn();

                rs[0] = rseq;

                return rs._retn();
            }//try
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::ACCESS_DENIED();
            }
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::OBJECT_NOT_EXISTS();
            }
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::USER_NOT_EXISTS();
            }
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::INCORRECT_USAGE();
            }
            catch (...)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }
        }

        Registry::DomainBrowser::RecordSet* Server_i::getDomainsForNsset(
            const Registry::DomainBrowser::RegistryReference& contact,
            const Registry::DomainBrowser::RegistryReference& nsset,
            const char* lang,
            ::CORBA::ULong offset,
            ::CORBA::Boolean& limit_exceeded)
        {
            try
            {
                RecordSet_var rs = new RecordSet;
                rs->length(1);

                RecordSequence_var rseq = new RecordSequence;
                rseq->length(1);

                RegistryObject_var robject = CORBA::string_dup("test_object");

                rseq[0] = robject._retn();

                rs[0] = rseq;

                return rs._retn();
            }//try
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::ACCESS_DENIED();
            }
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::OBJECT_NOT_EXISTS();
            }
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::USER_NOT_EXISTS();
            }
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::INCORRECT_USAGE();
            }
            catch (...)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }
        }

        Registry::DomainBrowser::ContactDetail* Server_i::getContactDetail(
            const Registry::DomainBrowser::RegistryReference& contact,
            const Registry::DomainBrowser::RegistryReference& detail,
            const char* lang,
            Registry::DomainBrowser::DataAccessLevel& auth_result)
        {
            try
            {
                ContactDetail_var contact_detail = new ContactDetail;
                return contact_detail._retn();
            }//try
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::OBJECT_NOT_EXISTS();
            }
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::USER_NOT_EXISTS();
            }
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::INCORRECT_USAGE();
            }
            catch (...)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }
        }

        Registry::DomainBrowser::NSSetDetail* Server_i::getNssetDetail(
            const Registry::DomainBrowser::RegistryReference& contact,
            const Registry::DomainBrowser::RegistryReference& nsset,
            const char* lang,
            Registry::DomainBrowser::DataAccessLevel& auth_result)
        {
            try
            {
                NSSetDetail_var nsset_detail = new NSSetDetail;
                return nsset_detail._retn();
            }//try
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::OBJECT_NOT_EXISTS();
            }
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::USER_NOT_EXISTS();
            }
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::INCORRECT_USAGE();
            }
            catch (...)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }
        }

        Registry::DomainBrowser::DomainDetail* Server_i::getDomainDetail(
            const Registry::DomainBrowser::RegistryReference& contact,
            const Registry::DomainBrowser::RegistryReference& domain,
            const char* lang,
            Registry::DomainBrowser::DataAccessLevel& auth_result)
        {
            try
            {
                DomainDetail_var domain_detail = new DomainDetail;
                return domain_detail._retn();
            }//try
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::OBJECT_NOT_EXISTS();
            }
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::USER_NOT_EXISTS();
            }
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::INCORRECT_USAGE();
            }
            catch (...)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }
        }

        Registry::DomainBrowser::KeysetDetail* Server_i::getKeysetDetail(
            const Registry::DomainBrowser::RegistryReference& contact,
            const Registry::DomainBrowser::RegistryReference& keyset,
            const char* lang,
            Registry::DomainBrowser::DataAccessLevel& auth_result)
        {
            try
            {
                KeysetDetail_var keyset_detail = new KeysetDetail;
                return keyset_detail._retn();
            }//try
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::OBJECT_NOT_EXISTS();
            }
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::USER_NOT_EXISTS();
            }
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::INCORRECT_USAGE();
            }
            catch (...)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }
        }

        Registry::DomainBrowser::RegistrarDetail* Server_i::getRegistrarDetail(
            const Registry::DomainBrowser::RegistryReference& contact,
            const char* handle)
        {
            try
            {
                Registry::DomainBrowserImpl::RegistrarDetail detail_impl
                    = pimpl_->getRegistrarDetail(contact.handle.in(), handle);

                RegistrarDetail_var registrar_detail = new RegistrarDetail;
                registrar_detail->id = detail_impl.id;
                registrar_detail->handle = CORBA::string_dup(detail_impl.handle.c_str());
                registrar_detail->name = CORBA::string_dup(detail_impl.name.c_str());
                registrar_detail->phone = CORBA::string_dup(detail_impl.phone.c_str());
                registrar_detail->fax = CORBA::string_dup(detail_impl.fax.c_str());
                registrar_detail->url = CORBA::string_dup(detail_impl.url.c_str());
                registrar_detail->address = CORBA::string_dup(detail_impl.address.c_str());

                return registrar_detail._retn();
            }//try
            catch (const Registry::DomainBrowserImpl::ObjectNotExists& )
            {
                throw Registry::DomainBrowser::OBJECT_NOT_EXISTS();
            }
            catch (const Registry::DomainBrowserImpl::UserNotExists& )
            {
                throw Registry::DomainBrowser::USER_NOT_EXISTS();
            }
            catch (const boost::exception&)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }
            catch (const std::exception&)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }
            catch (...)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }
        }

        ::CORBA::Boolean Server_i::setContactDiscloseFlags(
            const Registry::DomainBrowser::RegistryReference& contact,
            const Registry::DomainBrowser::UpdateContactDiscloseFlags& flags,
            Registry::DomainBrowser::TID request_id)
        {
            try
            {
                return false;
            }//try
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::OBJECT_BLOCKED();
            }
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::ACCESS_DENIED();
            }
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::USER_NOT_EXISTS();
            }
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::INCORRECT_USAGE();
            }
            catch (...)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }
        }

        ::CORBA::Boolean Server_i::setAuthInfo(
            const Registry::DomainBrowser::RegistryReference& contact,
            const char* objtype,
            const Registry::DomainBrowser::RegistryReference& objref,
            const char* auth_info,
            Registry::DomainBrowser::TID request_id)
        {
            try
            {
                return false;
            }//try
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::OBJECT_BLOCKED();
            }
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::ACCESS_DENIED();
            }
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::OBJECT_NOT_EXISTS();
            }

            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::USER_NOT_EXISTS();
            }
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::INCORRECT_USAGE();
            }
            catch (...)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }
        }

        ::CORBA::Boolean Server_i::setObjectBlockStatus(
            const Registry::DomainBrowser::RegistryReference& contact,
            const char* objtype,
            const Registry::DomainBrowser::RegistryReferenceSeq& objects,
            Registry::DomainBrowser::ObjectBlockType block,
            Registry::DomainBrowser::RecordSequence_out blocked)
        {
            try
            {
                return false;
            }//try
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::ACCESS_DENIED();
            }
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::OBJECT_NOT_EXISTS();
            }

            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::USER_NOT_EXISTS();
            }
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::INCORRECT_USAGE();
            }
            catch (...)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }
        }

        Registry::DomainBrowser::RecordSequence* Server_i::getPublicStatusDesc(const char* lang)
        {
            try
            {
                RecordSequence_var rseq = new RecordSequence;
                rseq->length(1);

                RegistryObject_var robject = CORBA::string_dup("test_object");

                rseq[0] = robject._retn();

                return rseq._retn();
            }//try
            catch (std::exception &_ex)
            {
                throw Registry::DomainBrowser::INCORRECT_USAGE();
            }
            catch (...)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }
        }

    }//namespace DomainBrowser
}//namespace Registry
