/*
 * Copyright (C) 2013  CZ.NIC, z.s.p.o.
 *
 * This file is part of FRED.
 *
 * FRED is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * FRED is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with FRED.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 *  @domain_browser_i.cc
 *  implementation of domain browser interface
 *  pregenerated by $> omniidl -bcxx -Wba -Wbexample -C./src/corba ~/workspace/enum/idl/idl/DomainBrowser.idl
 */

#include "domain_browser_i.h"
#include "src/domain_browser/domain_browser.h"
#include "src/corba/util/corba_conversions_string.h"
#include "src/corba/util/corba_conversions_datetime.h"
#include "src/corba/util/corba_conversions_nullable_types.h"
#include "src/corba/DomainBrowser.hh"
#include <string>

#include <boost/date_time/gregorian/gregorian.hpp>


namespace Registry
{
    namespace DomainBrowser
    {
        Server_i::Server_i(const std::string &_server_name,
            const std::string& _update_registrar_handle,
            unsigned int _domain_list_limit,
            unsigned int _nsset_list_limit,
            unsigned int _keyset_list_limit,
            unsigned int _contact_list_limit)
        : pimpl_(new Registry::DomainBrowserImpl::DomainBrowser(_server_name,
                    _update_registrar_handle, _domain_list_limit,
                    _nsset_list_limit, _keyset_list_limit, _contact_list_limit))
        {}

        Server_i::~Server_i()
        {}

        //   Methods corresponding to IDL attributes and operations
        ::CORBA::ULongLong Server_i::getContactId(const char* handle)
        {
            try
            {
                unsigned long long id = pimpl_->getContactId(Corba::unwrap_string_from_const_char_ptr(handle));
                return id;
            }//try
            catch (const Registry::DomainBrowserImpl::ObjectNotExists&)
            {
                throw Registry::DomainBrowser::OBJECT_NOT_EXISTS();
            }
            catch (...)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }

        }

        Nullable<Registry::DomainBrowser::NextDomainState> corba_wrap_nullable_next_domain_state
            (const Nullable<Registry::DomainBrowserImpl::NextDomainState>& in)
        {
            if(in.isnull()) return Nullable<Registry::DomainBrowser::NextDomainState>();

            Registry::DomainBrowser::NextDomainState ret;
            Registry::DomainBrowserImpl::NextDomainState next_state = in.get_value();

            ret.state_code = Corba::wrap_string_to_corba_string(next_state.state_code);
            ret.state_date = Corba::wrap_date_to_corba_string(next_state.state_date);
            return Nullable<Registry::DomainBrowser::NextDomainState>(ret);
        }

        DomainList_var corba_wrap_domain_list(const std::vector<Registry::DomainBrowserImpl::DomainListData>& domain_list)
        {
            DomainList_var dl = new DomainList;
            dl->length(domain_list.size());
            for(unsigned long long i = 0 ; i < domain_list.size(); ++i)
            {
                DomainListData dld;
                dld.id = domain_list.at(i).id;
                dld.fqdn = Corba::wrap_string_to_corba_string(domain_list.at(i).fqdn);
                dld.external_importance = domain_list.at(i).external_importance;

                Registry::DomainBrowser::NextDomainState corba_next_domain_state;

                dld.next_state = Corba::wrap_nullable_corba_type_to_corba_valuetype<NullableNextDomainState>(
                    corba_wrap_nullable_next_domain_state(domain_list.at(i).next_state));

                dld.have_keyset = domain_list.at(i).have_keyset;
                dld.user_role = Corba::wrap_string_to_corba_string(domain_list.at(i).user_role);
                dld.registrar_handle = Corba::wrap_string_to_corba_string(domain_list.at(i).registrar_handle);
                dld.registrar_name = Corba::wrap_string_to_corba_string(domain_list.at(i).registrar_name);

                dld.state_code.length(domain_list.at(i).state_code.size());
                for(unsigned long long j = 0; j < domain_list.at(i).state_code.size(); ++j)
                {
                    dld.state_code[j] = Corba::wrap_string_to_corba_string(domain_list.at(i).state_code.at(j));
                }

                dld.is_server_blocked = domain_list.at(i).is_server_blocked;

                dl[i] = dld;
            }
            return dl;
        }

        Registry::DomainBrowser::DomainList* Server_i::getDomainList(
            ::CORBA::ULongLong user_contact_id,
             Registry::DomainBrowser::NullableULongLong* contact_id_ptr,
            ::CORBA::ULong offset,
            ::CORBA::Boolean& limit_exceeded)
        {
            try
            {
                std::vector<Registry::DomainBrowserImpl::DomainListData> domain_list_out;
                limit_exceeded = pimpl_->getDomainList(user_contact_id,
                    (contact_id_ptr) ? Optional<unsigned long long>(contact_id_ptr->_value()) : Optional<unsigned long long>(),
                    Optional<unsigned long long>(), Optional<unsigned long long>(),
                    offset, domain_list_out);

                DomainList_var dl = corba_wrap_domain_list(domain_list_out);
                return dl._retn();
            }
            catch (const Registry::DomainBrowserImpl::ObjectNotExists& )
            {
                throw Registry::DomainBrowser::OBJECT_NOT_EXISTS();
            }
            catch (const Registry::DomainBrowserImpl::UserNotExists& )
            {
                throw Registry::DomainBrowser::USER_NOT_EXISTS();
            }
            catch (...)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }
        }


        NssetList_var corba_wrap_nsset_list(const std::vector<Registry::DomainBrowserImpl::NssetListData>& nsset_list)
        {
            NssetList_var nl = new NssetList;
            nl->length(nsset_list.size());

            for(unsigned long long i = 0 ; i < nsset_list.size(); ++i)
            {
                NssetListData nld;
                nld.id = nsset_list.at(i).id;
                nld.handle = Corba::wrap_string_to_corba_string(nsset_list.at(i).handle);
                nld.domain_count = nsset_list.at(i).domain_count;
                nld.registrar_handle = Corba::wrap_string_to_corba_string(nsset_list.at(i).registrar_handle);
                nld.registrar_name = Corba::wrap_string_to_corba_string(nsset_list.at(i).registrar_name);
                nld.external_importance = nsset_list.at(i).external_importance;
                nld.state_code.length(nsset_list.at(i).state_code.size());
                for(unsigned long long j = 0; j < nsset_list.at(i).state_code.size(); ++j)
                {
                    nld.state_code[j] = Corba::wrap_string_to_corba_string(nsset_list.at(i).state_code.at(j));
                }
                nld.is_server_blocked = nsset_list.at(i).is_server_blocked;
                nl[i] = nld;
            }

            return nl;
        }

        Registry::DomainBrowser::NssetList* Server_i::getNssetList(
            ::CORBA::ULongLong user_contact_id,
             Registry::DomainBrowser::NullableULongLong* contact_id_ptr,
            ::CORBA::ULong offset,
             ::CORBA::Boolean& limit_exceeded)
        {
            try
            {
                std::vector<Registry::DomainBrowserImpl::NssetListData> nsset_list_out;
                limit_exceeded = pimpl_->getNssetList(user_contact_id,
                    (contact_id_ptr) ? Optional<unsigned long long>(contact_id_ptr->_value()) : Optional<unsigned long long>(),
                    offset, nsset_list_out);

                NssetList_var nl = corba_wrap_nsset_list(nsset_list_out);
                return nl._retn();
            }
            catch (const Registry::DomainBrowserImpl::ObjectNotExists& )
            {
                throw Registry::DomainBrowser::OBJECT_NOT_EXISTS();
            }
            catch (const Registry::DomainBrowserImpl::UserNotExists& )
            {
                throw Registry::DomainBrowser::USER_NOT_EXISTS();
            }
            catch (...)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }
        }

        KeysetList_var corba_wrap_keyset_list(const std::vector<Registry::DomainBrowserImpl::KeysetListData>& keyset_list)
        {
            KeysetList_var kl = new KeysetList;
            kl->length(keyset_list.size());

            for(unsigned long long i = 0 ; i < keyset_list.size(); ++i)
            {
                KeysetListData kld;
                kld.id = keyset_list.at(i).id;
                kld.handle = Corba::wrap_string_to_corba_string(keyset_list.at(i).handle);
                kld.domain_count = keyset_list.at(i).domain_count;
                kld.registrar_handle = Corba::wrap_string_to_corba_string(keyset_list.at(i).registrar_handle);
                kld.registrar_name = Corba::wrap_string_to_corba_string(keyset_list.at(i).registrar_name);
                kld.external_importance = keyset_list.at(i).external_importance;
                kld.state_code.length(keyset_list.at(i).state_code.size());
                for(unsigned long long j = 0; j < keyset_list.at(i).state_code.size(); ++j)
                {
                    kld.state_code[j] = Corba::wrap_string_to_corba_string(keyset_list.at(i).state_code.at(j));
                }
                kld.is_server_blocked = keyset_list.at(i).is_server_blocked;
                kl[i] = kld;
            }

            return kl;
        }

        Registry::DomainBrowser::KeysetList* Server_i::getKeysetList(
            ::CORBA::ULongLong user_contact_id,
             Registry::DomainBrowser::NullableULongLong* contact_id_ptr,
            ::CORBA::ULong offset,
             ::CORBA::Boolean& limit_exceeded)
        {
            try
            {
                std::vector<Registry::DomainBrowserImpl::KeysetListData> keyset_list_out;
                limit_exceeded = pimpl_->getKeysetList(user_contact_id,
                    (contact_id_ptr) ? Optional<unsigned long long>(contact_id_ptr->_value()) : Optional<unsigned long long>(),
                    offset, keyset_list_out);
                KeysetList_var kl = corba_wrap_keyset_list(keyset_list_out);
                return kl._retn();
            }
            catch (const Registry::DomainBrowserImpl::ObjectNotExists& )
            {
                throw Registry::DomainBrowser::OBJECT_NOT_EXISTS();
            }
            catch (const Registry::DomainBrowserImpl::UserNotExists& )
            {
                throw Registry::DomainBrowser::USER_NOT_EXISTS();
            }
            catch (...)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }
        }

        Registry::DomainBrowser::DomainList*  Server_i::getDomainsForKeyset(
            ::CORBA::ULongLong user_contact_id,
            ::CORBA::ULongLong keyset_id,
            ::CORBA::ULong offset,
            ::CORBA::Boolean& limit_exceeded)
        {
            try
            {
                std::vector<Registry::DomainBrowserImpl::DomainListData> domain_list_out;
                limit_exceeded = pimpl_->getDomainList(user_contact_id,
                        Optional<unsigned long long>(),
                        Optional<unsigned long long>(),
                        Optional<unsigned long long>(keyset_id), offset, domain_list_out);

                DomainList_var dl = corba_wrap_domain_list(domain_list_out);
                return dl._retn();
            }
            catch (const Registry::DomainBrowserImpl::AccessDenied&)
            {
                throw Registry::DomainBrowser::ACCESS_DENIED();
            }
            catch (const Registry::DomainBrowserImpl::UserNotExists& )
            {
                throw Registry::DomainBrowser::USER_NOT_EXISTS();
            }
            catch (...)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }
        }

        Registry::DomainBrowser::DomainList* Server_i::getDomainsForNsset(
            ::CORBA::ULongLong user_contact_id,
            ::CORBA::ULongLong nsset_id,
            ::CORBA::ULong offset,
            ::CORBA::Boolean& limit_exceeded)
        {
            try
            {
                std::vector<Registry::DomainBrowserImpl::DomainListData> domain_list_out;

                limit_exceeded = pimpl_->getDomainList(user_contact_id,
                        Optional<unsigned long long>(),
                        Optional<unsigned long long>(nsset_id),
                        Optional<unsigned long long>(), offset, domain_list_out);

                DomainList_var dl = corba_wrap_domain_list(domain_list_out);
                return dl._retn();
            }
            catch (const Registry::DomainBrowserImpl::AccessDenied&)
            {
                throw Registry::DomainBrowser::ACCESS_DENIED();
            }
            catch (const Registry::DomainBrowserImpl::UserNotExists& )
            {
                throw Registry::DomainBrowser::USER_NOT_EXISTS();
            }
            catch (...)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }
        }

        Registry::DomainBrowser::ContactDetail* Server_i::getContactDetail(
            ::CORBA::ULongLong user_contact_id,
             ::CORBA::ULongLong detail_id,
            Registry::DomainBrowser::DataAccessLevel& auth_result)
        {
            try
            {
                Registry::DomainBrowserImpl::ContactDetail detail_impl
                    = pimpl_->getContactDetail(user_contact_id, detail_id);

                ContactDetail_var contact_detail = new ContactDetail;
                contact_detail->id = detail_impl.id;
                contact_detail->handle = Corba::wrap_string_to_corba_string(detail_impl.handle);
                contact_detail->roid = Corba::wrap_string_to_corba_string(detail_impl.roid);
                contact_detail->registrar.id = detail_impl.sponsoring_registrar.id;
                contact_detail->registrar.handle = Corba::wrap_string_to_corba_string(detail_impl.sponsoring_registrar.handle);
                contact_detail->registrar.name = Corba::wrap_string_to_corba_string(detail_impl.sponsoring_registrar.name);
                contact_detail->create_time = Corba::wrap_ptime_to_corba_string(detail_impl.creation_time);

                contact_detail->transfer_time = Corba::wrap_nullable_corba_type_to_corba_valuetype<NullableDateTimeIsoString>(
                    Corba::wrap_nullable_ptime_to_nullable_corba_string(detail_impl.transfer_time));
                contact_detail->update_time = Corba::wrap_nullable_corba_type_to_corba_valuetype<NullableDateTimeIsoString>(
                    Corba::wrap_nullable_ptime_to_nullable_corba_string(detail_impl.update_time));

                contact_detail->auth_info = Corba::wrap_string_to_corba_string(detail_impl.authinfopw);
                contact_detail->name = Corba::wrap_string_to_corba_string(detail_impl.name.get_value_or_default());
                contact_detail->organization = Corba::wrap_string_to_corba_string(detail_impl.organization.get_value_or_default());
                contact_detail->street1 = Corba::wrap_string_to_corba_string(detail_impl.street1.get_value_or_default());
                contact_detail->street2 = Corba::wrap_string_to_corba_string(detail_impl.street2.get_value_or_default());
                contact_detail->street3 = Corba::wrap_string_to_corba_string(detail_impl.street3.get_value_or_default());
                contact_detail->province = Corba::wrap_string_to_corba_string(detail_impl.stateorprovince.get_value_or_default());
                contact_detail->postalcode = Corba::wrap_string_to_corba_string(detail_impl.postalcode.get_value_or_default());
                contact_detail->city = Corba::wrap_string_to_corba_string(detail_impl.city.get_value_or_default());
                contact_detail->country = Corba::wrap_string_to_corba_string(detail_impl.country.get_value_or_default());
                contact_detail->telephone = Corba::wrap_string_to_corba_string(detail_impl.telephone.get_value_or_default());
                contact_detail->fax = Corba::wrap_string_to_corba_string(detail_impl.fax.get_value_or_default());
                contact_detail->email = Corba::wrap_string_to_corba_string(detail_impl.email.get_value_or_default());
                contact_detail->notify_email = Corba::wrap_string_to_corba_string(detail_impl.notifyemail.get_value_or_default());
                contact_detail->ssn = Corba::wrap_string_to_corba_string(detail_impl.ssn.get_value_or_default());
                contact_detail->ssn_type = Corba::wrap_string_to_corba_string(detail_impl.ssntype.get_value_or_default());
                contact_detail->vat = Corba::wrap_string_to_corba_string(detail_impl.vat.get_value_or_default());
                contact_detail->disclose_flags.address = detail_impl.disclose_flags.address;
                contact_detail->disclose_flags.email = detail_impl.disclose_flags.email;
                contact_detail->disclose_flags.fax = detail_impl.disclose_flags.fax;
                contact_detail->disclose_flags.ident = detail_impl.disclose_flags.ident;
                contact_detail->disclose_flags.name = detail_impl.disclose_flags.name;
                contact_detail->disclose_flags.notify_email = detail_impl.disclose_flags.notify_email;
                contact_detail->disclose_flags.organization = detail_impl.disclose_flags.organization;
                contact_detail->disclose_flags.telephone = detail_impl.disclose_flags.telephone;
                contact_detail->disclose_flags.vat = detail_impl.disclose_flags.vat;

                contact_detail->state_codes.length(detail_impl.state_codes.size());
                for(unsigned long long j = 0; j < detail_impl.state_codes.size(); ++j)
                {
                    contact_detail->state_codes[j] = Corba::wrap_string_to_corba_string(detail_impl.state_codes.at(j));
                }

                if(detail_impl.is_owner)
                {
                    auth_result = PRIVATE_DATA;
                }
                else
                {
                    auth_result = PUBLIC_DATA;
                }

                return contact_detail._retn();
            }
            catch (const Registry::DomainBrowserImpl::ObjectNotExists& )
            {
                throw Registry::DomainBrowser::OBJECT_NOT_EXISTS();
            }
            catch (const Registry::DomainBrowserImpl::UserNotExists& )
            {
                throw Registry::DomainBrowser::USER_NOT_EXISTS();
            }
            catch (...)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }
        }

        Registry::DomainBrowser::NSSetDetail* Server_i::getNssetDetail(
            ::CORBA::ULongLong user_contact_id,
             ::CORBA::ULongLong nsset_id,
            Registry::DomainBrowser::DataAccessLevel& auth_result)
        {
            try
            {
                Registry::DomainBrowserImpl::NssetDetail detail_impl
                    = pimpl_->getNssetDetail(user_contact_id, nsset_id);

                NSSetDetail_var nsset_detail = new NSSetDetail;

                nsset_detail->id = detail_impl.id;
                nsset_detail->handle = Corba::wrap_string_to_corba_string(detail_impl.handle);
                nsset_detail->roid = Corba::wrap_string_to_corba_string(detail_impl.roid);
                nsset_detail->registrar.id = detail_impl.sponsoring_registrar.id;
                nsset_detail->registrar.handle = Corba::wrap_string_to_corba_string(detail_impl.sponsoring_registrar.handle);
                nsset_detail->registrar.name = Corba::wrap_string_to_corba_string(detail_impl.sponsoring_registrar.name);
                nsset_detail->create_time = Corba::wrap_ptime_to_corba_string(detail_impl.creation_time);

                nsset_detail->transfer_time = Corba::wrap_nullable_corba_type_to_corba_valuetype<NullableDateTimeIsoString>(
                    Corba::wrap_nullable_ptime_to_nullable_corba_string(detail_impl.transfer_time));
                nsset_detail->update_time = Corba::wrap_nullable_corba_type_to_corba_valuetype<NullableDateTimeIsoString>(
                    Corba::wrap_nullable_ptime_to_nullable_corba_string(detail_impl.update_time));

                nsset_detail->create_registrar.id = detail_impl.create_registrar.id;
                nsset_detail->create_registrar.handle = Corba::wrap_string_to_corba_string(detail_impl.create_registrar.handle);
                nsset_detail->create_registrar.name = Corba::wrap_string_to_corba_string(detail_impl.create_registrar.name);

                nsset_detail->update_registrar.id = detail_impl.update_registrar.id;
                nsset_detail->update_registrar.handle = Corba::wrap_string_to_corba_string(detail_impl.update_registrar.handle);
                nsset_detail->update_registrar.name = Corba::wrap_string_to_corba_string(detail_impl.update_registrar.name);

                nsset_detail->auth_info = Corba::wrap_string_to_corba_string(detail_impl.authinfopw);

                nsset_detail->admins.length(detail_impl.admins.size());
                for(std::size_t i = 0; i < detail_impl.admins.size(); ++i)
                {
                    nsset_detail->admins[i].id = detail_impl.admins[i].id;
                    nsset_detail->admins[i].handle = Corba::wrap_string_to_corba_string(detail_impl.admins[i].handle);
                    nsset_detail->admins[i].name = Corba::wrap_string_to_corba_string(detail_impl.admins[i].name);
                }

                nsset_detail->hosts.length(detail_impl.hosts.size());
                for(std::size_t i = 0; i < detail_impl.hosts.size(); ++i)
                {
                    nsset_detail->hosts[i].fqdn = Corba::wrap_string_to_corba_string(detail_impl.hosts[i].get_fqdn());

                    std::vector<boost::asio::ip::address> inet_addrs = detail_impl.hosts[i].get_inet_addr();
                    nsset_detail->hosts[i].inet.length(inet_addrs.size());
                    for(std::size_t j = 0; j < inet_addrs.size(); ++j)
                    {
                        nsset_detail->hosts[i].inet[j] = Corba::wrap_string_to_corba_string(inet_addrs.at(j).to_string());
                    }
                }

                nsset_detail->state_codes.length(detail_impl.state_codes.size());
                for(unsigned long long j = 0; j < detail_impl.state_codes.size(); ++j)
                {
                    nsset_detail->state_codes[j] = Corba::wrap_string_to_corba_string(detail_impl.state_codes.at(j));
                }


                nsset_detail->report_level = detail_impl.report_level;

                if(detail_impl.is_owner)
                {
                    auth_result = PRIVATE_DATA;
                }
                else
                {
                    auth_result = PUBLIC_DATA;
                }

                return nsset_detail._retn();
            }
            catch (const Registry::DomainBrowserImpl::ObjectNotExists& )
            {
                throw Registry::DomainBrowser::OBJECT_NOT_EXISTS();
            }
            catch (const Registry::DomainBrowserImpl::UserNotExists& )
            {
                throw Registry::DomainBrowser::USER_NOT_EXISTS();
            }
            catch (...)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }
        }

        Registry::DomainBrowser::DomainDetail* Server_i::getDomainDetail(
            ::CORBA::ULongLong user_contact_id,
             ::CORBA::ULongLong domain_id,
            Registry::DomainBrowser::DataAccessLevel& auth_result)
        {
            try
            {
                Registry::DomainBrowserImpl::DomainDetail detail_impl
                    = pimpl_->getDomainDetail(user_contact_id, domain_id);

                DomainDetail_var domain_detail = new DomainDetail;
                domain_detail->id = detail_impl.id;
                domain_detail->fqdn = Corba::wrap_string_to_corba_string(detail_impl.fqdn);
                domain_detail->roid = Corba::wrap_string_to_corba_string(detail_impl.roid);
                domain_detail->registrar.id = detail_impl.sponsoring_registrar.id;
                domain_detail->registrar.handle = Corba::wrap_string_to_corba_string(detail_impl.sponsoring_registrar.handle);
                domain_detail->registrar.name = Corba::wrap_string_to_corba_string(detail_impl.sponsoring_registrar.name);
                domain_detail->create_time = Corba::wrap_ptime_to_corba_string(detail_impl.creation_time);

                domain_detail->update_time = Corba::wrap_nullable_corba_type_to_corba_valuetype<NullableDateTimeIsoString>(
                    Corba::wrap_nullable_ptime_to_nullable_corba_string(detail_impl.update_time));

                domain_detail->auth_info = Corba::wrap_string_to_corba_string(detail_impl.authinfopw);
                domain_detail->registrant.id = detail_impl.registrant.id;
                domain_detail->registrant.handle = Corba::wrap_string_to_corba_string(detail_impl.registrant.handle);
                domain_detail->registrant.name = Corba::wrap_string_to_corba_string(detail_impl.registrant.name);

                domain_detail->expiration_date = Corba::wrap_date_to_corba_string(detail_impl.expiration_date);

                domain_detail->is_enum = !detail_impl.enum_domain_validation.isnull();
                if(domain_detail->is_enum)
                {
                    domain_detail->publish = detail_impl.enum_domain_validation.get_value().publish;

                    if(!detail_impl.enum_domain_validation.get_value().validation_expiration.is_special())
                    {
                        domain_detail->val_ex_date = new NullableDateIsoString(boost::gregorian::to_iso_extended_string(
                            detail_impl.enum_domain_validation.get_value().validation_expiration).c_str());
                    }
                    else
                    {
                        domain_detail->val_ex_date = 0;
                    }
                }
                else
                {
                    domain_detail->publish = false;
                    domain_detail->val_ex_date = 0;
                }

                domain_detail->nsset.id = detail_impl.nsset.id;
                domain_detail->nsset.handle = CORBA::string_dup(detail_impl.nsset.handle.c_str());
                domain_detail->nsset.name = CORBA::string_dup(detail_impl.nsset.name.c_str());

                domain_detail->keyset.id = detail_impl.keyset.id;
                domain_detail->keyset.handle = CORBA::string_dup(detail_impl.keyset.handle.c_str());
                domain_detail->keyset.name = CORBA::string_dup(detail_impl.keyset.name.c_str());

                domain_detail->admins.length(detail_impl.admins.size());

                for(std::size_t i = 0; i < detail_impl.admins.size(); ++i)
                {
                    domain_detail->admins[i].id = detail_impl.admins[i].id;
                    domain_detail->admins[i].handle = CORBA::string_dup(detail_impl.admins[i].handle.c_str());
                    domain_detail->admins[i].name = CORBA::string_dup(detail_impl.admins[i].name.c_str());
                }

                domain_detail->state_codes.length(detail_impl.state_codes.size());
                for(unsigned long long j = 0; j < detail_impl.state_codes.size(); ++j)
                {
                    domain_detail->state_codes[j] = CORBA::string_dup(detail_impl.state_codes.at(j).c_str());
                }


                if(detail_impl.is_owner || detail_impl.is_admin)
                {
                    auth_result = PRIVATE_DATA;
                }
                else
                {
                    auth_result = PUBLIC_DATA;
                }

                return domain_detail._retn();
            }
            catch (const Registry::DomainBrowserImpl::ObjectNotExists& )
            {
                throw Registry::DomainBrowser::OBJECT_NOT_EXISTS();
            }
            catch (const Registry::DomainBrowserImpl::UserNotExists& )
            {
                throw Registry::DomainBrowser::USER_NOT_EXISTS();
            }
            catch (...)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }
        }

        Registry::DomainBrowser::KeysetDetail* Server_i::getKeysetDetail(
            ::CORBA::ULongLong user_contact_id,
             ::CORBA::ULongLong keyset_id,
            Registry::DomainBrowser::DataAccessLevel& auth_result)
        {
            try
            {
                Registry::DomainBrowserImpl::KeysetDetail detail_impl
                    = pimpl_->getKeysetDetail(user_contact_id, keyset_id);

                KeysetDetail_var keyset_detail = new KeysetDetail;

                keyset_detail->id = detail_impl.id;
                keyset_detail->handle = CORBA::string_dup(detail_impl.handle.c_str());
                keyset_detail->roid = CORBA::string_dup(detail_impl.roid.c_str());
                keyset_detail->registrar.id = detail_impl.sponsoring_registrar.id;
                keyset_detail->registrar.handle = CORBA::string_dup(detail_impl.sponsoring_registrar.handle.c_str());
                keyset_detail->registrar.name = CORBA::string_dup(detail_impl.sponsoring_registrar.name.c_str());
                keyset_detail->create_time = CORBA::string_dup(boost::posix_time::to_iso_extended_string(detail_impl.creation_time).c_str());

                if(!detail_impl.transfer_time.isnull() && !detail_impl.transfer_time.get_value().is_special())
                {
                    keyset_detail->transfer_time = new NullableDateTimeIsoString(boost::posix_time::to_iso_extended_string(detail_impl.transfer_time.get_value()).c_str());
                }
                else
                {
                    keyset_detail->transfer_time = 0;
                }

                if(!detail_impl.update_time.isnull() && !detail_impl.update_time.get_value().is_special())
                {
                    keyset_detail->update_time = new NullableDateTimeIsoString(boost::posix_time::to_iso_extended_string(detail_impl.update_time.get_value()).c_str());
                }
                else
                {
                    keyset_detail->update_time = 0;
                }

                keyset_detail->create_registrar.id = detail_impl.create_registrar.id;
                keyset_detail->create_registrar.handle = CORBA::string_dup(detail_impl.create_registrar.handle.c_str());
                keyset_detail->create_registrar.name = CORBA::string_dup(detail_impl.create_registrar.name.c_str());

                keyset_detail->update_registrar.id = detail_impl.update_registrar.id;
                keyset_detail->update_registrar.handle = CORBA::string_dup(detail_impl.update_registrar.handle.c_str());
                keyset_detail->update_registrar.name = CORBA::string_dup(detail_impl.update_registrar.name.c_str());

                keyset_detail->auth_info = CORBA::string_dup(detail_impl.authinfopw.c_str());

                keyset_detail->admins.length(detail_impl.admins.size());
                for(std::size_t i = 0; i < detail_impl.admins.size(); ++i)
                {
                    keyset_detail->admins[i].id = detail_impl.admins[i].id;
                    keyset_detail->admins[i].handle = CORBA::string_dup(detail_impl.admins[i].handle.c_str());
                    keyset_detail->admins[i].name = CORBA::string_dup(detail_impl.admins[i].name.c_str());
                }

                keyset_detail->dnskeys.length(detail_impl.dnskeys.size());
                for(std::size_t i = 0; i < detail_impl.dnskeys.size(); ++i)
                {
                    keyset_detail->dnskeys[i].flags = detail_impl.dnskeys[i].flags;
                    keyset_detail->dnskeys[i].protocol = detail_impl.dnskeys[i].protocol;
                    keyset_detail->dnskeys[i].alg = detail_impl.dnskeys[i].alg;
                    keyset_detail->dnskeys[i].key = CORBA::string_dup(detail_impl.dnskeys[i].key.c_str());
                }

                keyset_detail->state_codes.length(detail_impl.state_codes.size());
                for(unsigned long long j = 0; j < detail_impl.state_codes.size(); ++j)
                {
                    keyset_detail->state_codes[j] = CORBA::string_dup(detail_impl.state_codes.at(j).c_str());
                }

                if(detail_impl.is_owner)
                {
                    auth_result = PRIVATE_DATA;
                }
                else
                {
                    auth_result = PUBLIC_DATA;
                }

                return keyset_detail._retn();
            }
            catch (const Registry::DomainBrowserImpl::ObjectNotExists& )
            {
                throw Registry::DomainBrowser::OBJECT_NOT_EXISTS();
            }
            catch (const Registry::DomainBrowserImpl::UserNotExists& )
            {
                throw Registry::DomainBrowser::USER_NOT_EXISTS();
            }
            catch (...)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }
        }

        Registry::DomainBrowser::RegistrarDetail* Server_i::getRegistrarDetail(
            ::CORBA::ULongLong user_contact_id,
            const char* handle)
        {
            try
            {
                Registry::DomainBrowserImpl::RegistrarDetail detail_impl
                    = pimpl_->getRegistrarDetail(user_contact_id, handle);

                RegistrarDetail_var registrar_detail = new RegistrarDetail;
                registrar_detail->id = detail_impl.id;
                registrar_detail->handle = CORBA::string_dup(detail_impl.handle.c_str());
                registrar_detail->name = CORBA::string_dup(detail_impl.name.c_str());
                registrar_detail->phone = CORBA::string_dup(detail_impl.phone.c_str());
                registrar_detail->fax = CORBA::string_dup(detail_impl.fax.c_str());
                registrar_detail->url = CORBA::string_dup(detail_impl.url.c_str());
                registrar_detail->address = CORBA::string_dup(detail_impl.address.c_str());

                return registrar_detail._retn();
            }
            catch (const Registry::DomainBrowserImpl::ObjectNotExists& )
            {
                throw Registry::DomainBrowser::OBJECT_NOT_EXISTS();
            }
            catch (const Registry::DomainBrowserImpl::UserNotExists& )
            {
                throw Registry::DomainBrowser::USER_NOT_EXISTS();
            }
            catch (...)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }
        }

        ::CORBA::Boolean Server_i::setContactDiscloseFlags(
            ::CORBA::ULongLong user_contact_id,
            const Registry::DomainBrowser::UpdateContactDiscloseFlags& flags,
            ::CORBA::ULongLong request_id)
        {
            try
            {
                Registry::DomainBrowserImpl::ContactDiscloseFlagsToSet flags_;
                flags_.email = flags.email;
                flags_.address = flags.address;
                flags_.telephone = flags.telephone;
                flags_.fax = flags.fax;
                flags_.ident = flags.ident;
                flags_.vat = flags.vat;
                flags_.notify_email = flags.notify_email;
                return pimpl_->setContactDiscloseFlags(user_contact_id, flags_, request_id);
            }
            catch (const Registry::DomainBrowserImpl::UserNotExists& )
            {
                throw Registry::DomainBrowser::USER_NOT_EXISTS();
            }
            catch (const Registry::DomainBrowserImpl::IncorrectUsage& )
            {
                throw Registry::DomainBrowser::INCORRECT_USAGE();
            }
            catch (const Registry::DomainBrowserImpl::ObjectBlocked& )
            {
                throw Registry::DomainBrowser::OBJECT_BLOCKED();
            }
            catch (const Registry::DomainBrowserImpl::AccessDenied& )
            {
                throw Registry::DomainBrowser::ACCESS_DENIED();
            }
            catch (...)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }
        }

        ::CORBA::Boolean Server_i::setContactAuthInfo(
            ::CORBA::ULongLong user_contact_id,
            const char* auth_info,
            ::CORBA::ULongLong request_id)
        {
            try
            {
                return pimpl_->setContactAuthInfo(user_contact_id, auth_info, request_id);
            }
            catch (const Registry::DomainBrowserImpl::UserNotExists& )
            {
                throw Registry::DomainBrowser::USER_NOT_EXISTS();
            }
            catch (const Registry::DomainBrowserImpl::IncorrectUsage& )
            {
                throw Registry::DomainBrowser::INCORRECT_USAGE();
            }
            catch (const Registry::DomainBrowserImpl::ObjectBlocked& )
            {
                throw Registry::DomainBrowser::OBJECT_BLOCKED();
            }
            catch (const Registry::DomainBrowserImpl::AccessDenied& )
            {
                throw Registry::DomainBrowser::ACCESS_DENIED();
            }
            catch (...)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }
        }

        ::CORBA::Boolean Server_i::setObjectBlockStatus(
            ::CORBA::ULongLong user_contact_id,
            const char* objtype,
            const Registry::DomainBrowser::ObjectIdSeq& objects,
            Registry::DomainBrowser::ObjectBlockType block,
            Registry::DomainBrowser::RefusedObjectHandleSequence_out change_prohibited)
        {
            try
            {
                std::vector<unsigned long long> objects_id;
                objects_id.reserve(objects.length());
                for(std::size_t i = 0; i < objects.length(); ++i)
                {
                    objects_id.push_back(objects[i]);
                }
                std::vector<std::string> blocked_objects;

                bool ret = pimpl_->setObjectBlockStatus(user_contact_id, objtype, objects_id,
                        (block == Registry::DomainBrowser::BLOCK_TRANSFER) ? Registry::DomainBrowserImpl::BLOCK_TRANSFER
                        : (block == Registry::DomainBrowser::UNBLOCK_TRANSFER) ? Registry::DomainBrowserImpl::UNBLOCK_TRANSFER
                        : (block == Registry::DomainBrowser::BLOCK_TRANSFER_AND_UPDATE) ? Registry::DomainBrowserImpl::BLOCK_TRANSFER_AND_UPDATE
                        : (block == Registry::DomainBrowser::UNBLOCK_TRANSFER_AND_UPDATE) ? Registry::DomainBrowserImpl::UNBLOCK_TRANSFER_AND_UPDATE
                        : Registry::DomainBrowserImpl::INVALID_BLOCK_TYPE
                        , blocked_objects);

                Registry::DomainBrowser::RefusedObjectHandleSequence_var change_prohibited_var = new Registry::DomainBrowser::RefusedObjectHandleSequence;
                change_prohibited_var->length(blocked_objects.size());
                for(std::size_t i = 0; i < blocked_objects.size(); ++i)
                {
                    change_prohibited_var[i] = CORBA::string_dup(blocked_objects.at(i).c_str());
                }

                change_prohibited = change_prohibited_var._retn();//transfer ownership to the out parameter, no exceptions allowed after this point
                return ret;
            }
            catch (const Registry::DomainBrowserImpl::ObjectNotExists& )
            {
                throw Registry::DomainBrowser::OBJECT_NOT_EXISTS();
            }
            catch (const Registry::DomainBrowserImpl::UserNotExists& )
            {
                throw Registry::DomainBrowser::USER_NOT_EXISTS();
            }
            catch (const Registry::DomainBrowserImpl::IncorrectUsage& )
            {
                throw Registry::DomainBrowser::INCORRECT_USAGE();
            }
            catch (const Registry::DomainBrowserImpl::AccessDenied& )
            {
                throw Registry::DomainBrowser::ACCESS_DENIED();
            }
            catch (...)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }
        }

        Registry::DomainBrowser::StatusDescList* Server_i::getPublicStatusDesc(const char* lang)
        {
            try
            {
                std::vector<Registry::DomainBrowserImpl::StatusDesc> status_description_out;
                pimpl_->getPublicStatusDesc(lang, status_description_out);
                Registry::DomainBrowser::StatusDescList_var status_description_var = new Registry::DomainBrowser::StatusDescList;
                status_description_var->length(status_description_out.size());
                for(std::size_t i = 0; i < status_description_out.size(); ++i)
                {
                    status_description_var[i].state_code = CORBA::string_dup(status_description_out.at(i).state_code.c_str());
                    status_description_var[i].state_desc = CORBA::string_dup(status_description_out.at(i).state_desc.c_str());
                }
                return  status_description_var._retn();
            }
            catch (...)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }
        }

        MergeContactCandidateList_var corba_wrap_merge_contact_candidate_list(const std::vector<Registry::DomainBrowserImpl::MergeContactCandidateData>& candidate_list)
        {
            MergeContactCandidateList_var cl = new MergeContactCandidateList;
            cl->length(candidate_list.size());

            for(unsigned long long i = 0 ; i < candidate_list.size(); ++i)
            {
                MergeContactCandidateData cld;
                cld.id = candidate_list.at(i).id;
                cld.handle = CORBA::string_dup(candidate_list.at(i).handle.c_str());
                cld.domain_count = candidate_list.at(i).domain_count;
                cld.nsset_count = candidate_list.at(i).nsset_count;
                cld.keyset_count = candidate_list.at(i).keyset_count;
                cld.registrar_handle = CORBA::string_dup(candidate_list.at(i).registrar_handle.c_str());
                cld.registrar_name = CORBA::string_dup(candidate_list.at(i).registrar_name.c_str());

                cl[i] = cld;
            }

            return cl;
        }


        Registry::DomainBrowser::MergeContactCandidateList* Server_i::getMergeContactCandidateList(
            ::CORBA::ULongLong user_contact_id,
            ::CORBA::ULong offset, ::CORBA::Boolean& limit_exceeded)
        {
            try
            {
                std::vector<Registry::DomainBrowserImpl::MergeContactCandidateData> contact_list_out;
                limit_exceeded = pimpl_->getMergeContactCandidateList(user_contact_id,
                    offset, contact_list_out);

                MergeContactCandidateList_var cl = corba_wrap_merge_contact_candidate_list(contact_list_out);
                return cl._retn();
            }
            catch (const Registry::DomainBrowserImpl::UserNotExists& )
            {
                throw Registry::DomainBrowser::USER_NOT_EXISTS();
            }
            catch (...)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }
        }

        void Server_i::mergeContacts(::CORBA::ULongLong dst_contact_id,
            const Registry::DomainBrowser::ObjectIdSeq& src_contact_id_list,
            ::CORBA::ULongLong request_id)
        {
            try
            {
                std::vector<unsigned long long> contact_list;
                contact_list.reserve(src_contact_id_list.length());
                for(std::size_t i = 0; i < src_contact_id_list.length(); ++i)
                {
                    contact_list.push_back(src_contact_id_list[i]);
                }
                pimpl_->mergeContacts(dst_contact_id, contact_list, request_id);
            }
            catch (const Registry::DomainBrowserImpl::UserNotExists& )
            {
                throw Registry::DomainBrowser::USER_NOT_EXISTS();
            }
            catch (const Registry::DomainBrowserImpl::InvalidContacts& )
            {
                throw Registry::DomainBrowser::INVALID_CONTACTS();
            }
            catch (...)
            {
                throw Registry::DomainBrowser::INTERNAL_SERVER_ERROR();
            }
        }


    }//namespace DomainBrowser
}//namespace Registry
