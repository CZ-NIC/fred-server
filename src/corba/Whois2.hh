// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __Whois2_hh__
#define __Whois2_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_Whois2
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_Whois2
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_Whois2
#endif



#ifndef __DateTime_hh_EXTERNAL_GUARD__
#define __DateTime_hh_EXTERNAL_GUARD__
#include <DateTime.hh>
#endif
#ifndef __NullableTypes_hh_EXTERNAL_GUARD__
#define __NullableTypes_hh_EXTERNAL_GUARD__
#include <NullableTypes.hh>
#endif



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE Registry

_CORBA_MODULE_BEG

  _CORBA_MODULE Whois

  _CORBA_MODULE_BEG

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_StringSeq;

    class StringSeq_var;

    class StringSeq : public _CORBA_Unbounded_Sequence_String {
    public:
      typedef StringSeq_var _var_type;
      inline StringSeq() {}
      inline StringSeq(const StringSeq& _s)
        : _CORBA_Unbounded_Sequence_String(_s) {}

      inline StringSeq(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_String(_max) {}
      inline StringSeq(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

    

      inline StringSeq& operator = (const StringSeq& _s) {
        _CORBA_Unbounded_Sequence_String::operator=(_s);
        return *this;
      }
    };

    class StringSeq_out;

    class StringSeq_var {
    public:
      inline StringSeq_var() : _pd_seq(0) {}
      inline StringSeq_var(StringSeq* _s) : _pd_seq(_s) {}
      inline StringSeq_var(const StringSeq_var& _s) {
        if( _s._pd_seq )  _pd_seq = new StringSeq(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~StringSeq_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline StringSeq_var& operator = (StringSeq* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline StringSeq_var& operator = (const StringSeq_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new StringSeq;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline StringSeq* operator -> () { return _pd_seq; }
      inline const StringSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator StringSeq& () const { return *_pd_seq; }
#else
      inline operator const StringSeq& () const { return *_pd_seq; }
      inline operator StringSeq& () { return *_pd_seq; }
#endif
        
      inline const StringSeq& in() const { return *_pd_seq; }
      inline StringSeq&       inout()    { return *_pd_seq; }
      inline StringSeq*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline StringSeq* _retn() { StringSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class StringSeq_out;
      
    private:
      StringSeq* _pd_seq;
    };

    class StringSeq_out {
    public:
      inline StringSeq_out(StringSeq*& _s) : _data(_s) { _data = 0; }
      inline StringSeq_out(StringSeq_var& _s)
        : _data(_s._pd_seq) { _s = (StringSeq*) 0; }
      inline StringSeq_out(const StringSeq_out& _s) : _data(_s._data) {}
      inline StringSeq_out& operator = (const StringSeq_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline StringSeq_out& operator = (StringSeq* _s) {
        _data = _s;
        return *this;
      }
      inline operator StringSeq*&()  { return _data; }
      inline StringSeq*& ptr()       { return _data; }
      inline StringSeq* operator->() { return _data; }

      inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      StringSeq*& _data;

    private:
      StringSeq_out();
      StringSeq_out& operator=(const StringSeq_var&);
    };

#ifndef __Registry_mWhois_mDisclosableString__
#define __Registry_mWhois_mDisclosableString__

    class DisclosableString;

    class DisclosableString_Helper {
    public:
      static void add_ref(DisclosableString*);
      static void remove_ref(DisclosableString*);
      static void marshal(DisclosableString*, cdrStream&);
      static DisclosableString* unmarshal(cdrStream&);
    };

    typedef _CORBA_Value_Var    <DisclosableString,DisclosableString_Helper> DisclosableString_var;
    typedef _CORBA_Value_Member <DisclosableString,DisclosableString_Helper> DisclosableString_member;
    typedef _CORBA_Value_OUT_arg<DisclosableString,DisclosableString_Helper> DisclosableString_out;

#endif // __Registry_mWhois_mDisclosableString__

    class DisclosableString :
      public ::CORBA::DefaultValueRefCountBase
    {
    public:
      typedef DisclosableString_var _var_type;

      inline DisclosableString()
        : _pd_boxed(OMNI_CONST_CAST(char*,_CORBA_String_helper::empty_string))
      {}
      inline DisclosableString(const DisclosableString& _v) :
        ValueBase (_v), DefaultValueRefCountBase (_v) {
        if (_v._pd_boxed) _pd_boxed = _CORBA_String_helper::dup(_v._pd_boxed);
        else _pd_boxed = 0;
      }
      inline DisclosableString(char* _v) {
        _pd_boxed = _v;
      }
      inline DisclosableString(const char* _v) {
        if (_v) _pd_boxed = _CORBA_String_helper::dup(_v);
        else _pd_boxed = 0;
      }
      inline DisclosableString(const ::CORBA::String_var& _v) {
        if ((const char*)_v) _pd_boxed = _CORBA_String_helper::dup(_v);
        else _pd_boxed = 0;
      }
      inline DisclosableString(const ::CORBA::String_member& _v) {
        if ((const char*)_v) _pd_boxed = _CORBA_String_helper::dup(_v);
        else _pd_boxed = 0;
      }
      inline DisclosableString(const _CORBA_String_element& _v) {
        if ((const char*)_v) _pd_boxed = _CORBA_String_helper::dup(_v);
        else _pd_boxed = 0;
      }

      inline DisclosableString& operator=(char* _v) {
        _CORBA_String_helper::free(_pd_boxed);
        _pd_boxed = _v;
        return *this;
      }
      inline DisclosableString& operator=(const char* _v) {
        _CORBA_String_helper::free(_pd_boxed);
        if (_v) _pd_boxed = _CORBA_String_helper::dup(_v);
        else _pd_boxed = 0;
        return *this;
      }
      inline DisclosableString& operator=(const ::CORBA::String_var& _v) {
        _CORBA_String_helper::free(_pd_boxed);
        if ((const char*)_v) _pd_boxed = _CORBA_String_helper::dup(_v);
        else _pd_boxed = 0;
        return *this;
      }
      inline DisclosableString& operator=(const ::CORBA::String_member& _v) {
        _CORBA_String_helper::free(_pd_boxed);
        if ((const char*)_v) _pd_boxed = _CORBA_String_helper::dup(_v);
        else _pd_boxed = 0;
        return *this;
      }
      inline DisclosableString& operator=(const _CORBA_String_element& _v) {
        _CORBA_String_helper::free(_pd_boxed);
        if ((const char*)_v) _pd_boxed = _CORBA_String_helper::dup(_v);
        else _pd_boxed = 0;
        return *this;
      }

      inline const char* _value() const {
        return _pd_boxed;
      }
      inline void _value(char* _v) {
        _CORBA_String_helper::free(_pd_boxed);
        _pd_boxed = _v;
      }
      inline void _value(const char* _v) {
        _CORBA_String_helper::free(_pd_boxed);
        if (_v) _pd_boxed = _CORBA_String_helper::dup(_v);
        else _pd_boxed = 0;
      }
      inline void _value(const ::CORBA::String_var& _v) {
        _CORBA_String_helper::free(_pd_boxed);
        if ((const char*)_v) _pd_boxed = _CORBA_String_helper::dup(_v);
        else _pd_boxed = 0;
      }
      inline void _value(const ::CORBA::String_member& _v) {
        _CORBA_String_helper::free(_pd_boxed);
        if ((const char*)_v) _pd_boxed = _CORBA_String_helper::dup(_v);
        else _pd_boxed = 0;
      }
      inline void _value(const _CORBA_String_element& _v) {
        _CORBA_String_helper::free(_pd_boxed);
        if ((const char*)_v) _pd_boxed = _CORBA_String_helper::dup(_v);
        else _pd_boxed = 0;
      }

      inline char& operator[] (_CORBA_ULong _i) {
        if (!_pd_boxed) {
          _CORBA_bound_check_error();	// never return
        }
        return _pd_boxed[_i];
      }
      inline char operator[] (_CORBA_ULong _i) const {
        if (!_pd_boxed) {
          _CORBA_bound_check_error();	// never return
        }
        return _pd_boxed[_i];
      }

      inline const char* _boxed_in() const {
        return _pd_boxed;
      }
      inline char*& _boxed_inout() {
        return _pd_boxed;
      }
      inline char*& _boxed_out() {
        return _pd_boxed;
      }

    

      static DisclosableString* _downcast(::CORBA::ValueBase*);

#ifdef OMNI_HAVE_COVARIANT_RETURNS
      virtual DisclosableString* _copy_value();
#else
      virtual ::CORBA::ValueBase* _copy_value();
#endif

      // omniORB internal
      virtual const char* _NP_repositoryId() const;
      virtual const char* _NP_repositoryId(::CORBA::ULong& _hashval) const;

      virtual const _omni_ValueIds* _NP_truncatableIds() const;

      virtual ::CORBA::Boolean _NP_custom() const;
      virtual ::CORBA::Boolean _NP_box() const;

      virtual void* _ptrToValue(const char* id);

      static void _NP_marshal(DisclosableString*, cdrStream&);
      static DisclosableString* _NP_unmarshal(cdrStream&);

      virtual void _PR_marshal_state(cdrStream&) const;
      virtual void _PR_unmarshal_state(cdrStream&);
      virtual void _PR_copy_state(DisclosableString*);

      static _core_attr const char* _PD_repoId;

    protected:
      ~DisclosableString();
    private:
      void operator=(const DisclosableString&);

      char* _pd_boxed;
    };

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DisclosableString;

    struct PostalAddress {
      typedef _CORBA_ConstrType_Variable_Var<PostalAddress> _var_type;

      
      ::CORBA::String_member street1;

      ::CORBA::String_member street2;

      ::CORBA::String_member street3;

      ::CORBA::String_member city;

      ::CORBA::String_member stateorprovince;

      ::CORBA::String_member postalcode;

      ::CORBA::String_member country_code;

      ::CORBA::String_member telephone;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef PostalAddress::_var_type PostalAddress_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< PostalAddress,PostalAddress_var > PostalAddress_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PostalAddress;

#ifndef __Registry_mWhois_mDisclosablePostalAddress__
#define __Registry_mWhois_mDisclosablePostalAddress__

    class DisclosablePostalAddress;

    class DisclosablePostalAddress_Helper {
    public:
      static void add_ref(DisclosablePostalAddress*);
      static void remove_ref(DisclosablePostalAddress*);
      static void marshal(DisclosablePostalAddress*, cdrStream&);
      static DisclosablePostalAddress* unmarshal(cdrStream&);
    };

    typedef _CORBA_Value_Var    <DisclosablePostalAddress,DisclosablePostalAddress_Helper> DisclosablePostalAddress_var;
    typedef _CORBA_Value_Member <DisclosablePostalAddress,DisclosablePostalAddress_Helper> DisclosablePostalAddress_member;
    typedef _CORBA_Value_OUT_arg<DisclosablePostalAddress,DisclosablePostalAddress_Helper> DisclosablePostalAddress_out;

#endif // __Registry_mWhois_mDisclosablePostalAddress__

    class DisclosablePostalAddress :
      public ::CORBA::DefaultValueRefCountBase
    {
    public:
      typedef DisclosablePostalAddress_var _var_type;

      inline DisclosablePostalAddress() {
        _pd_boxed = new PostalAddress();
      };
      inline DisclosablePostalAddress(const PostalAddress& _v) {
        _pd_boxed = new PostalAddress(_v);
      };
      inline DisclosablePostalAddress(const DisclosablePostalAddress& _v) :
        ValueBase (_v), DefaultValueRefCountBase (_v) {
        _pd_boxed = new PostalAddress(_v._pd_boxed.in());
      };

      inline DisclosablePostalAddress& operator=(const PostalAddress& _v) {
        _pd_boxed = new PostalAddress(_v);
        return *this;
      }

      inline const PostalAddress& _value() const {
        return _pd_boxed.in();
      }
      inline PostalAddress& _value() {
        return _pd_boxed.inout();
      }
      inline void _value(const PostalAddress& _v) {
        _pd_boxed = new PostalAddress(_v);
      }

      inline const PostalAddress& _boxed_in() const {
        return _pd_boxed.in();
      }
      inline PostalAddress& _boxed_inout() {
        return _pd_boxed.inout();
      }
      inline PostalAddress_out _boxed_out() {
        return _pd_boxed.out();
      }

      // Member accessors
      inline const char* street1() const
      {
        return _pd_boxed->street1;
      }
      inline void street1(char* _value)
      {
        _pd_boxed->street1 = _value;
      }
      inline void street1(const char* _value)
      {
        _pd_boxed->street1 = _value;
      }
      inline void street1(const ::CORBA::String_var& _value)
      {
        _pd_boxed->street1 = _value;
      }

      inline const char* street2() const
      {
        return _pd_boxed->street2;
      }
      inline void street2(char* _value)
      {
        _pd_boxed->street2 = _value;
      }
      inline void street2(const char* _value)
      {
        _pd_boxed->street2 = _value;
      }
      inline void street2(const ::CORBA::String_var& _value)
      {
        _pd_boxed->street2 = _value;
      }

      inline const char* street3() const
      {
        return _pd_boxed->street3;
      }
      inline void street3(char* _value)
      {
        _pd_boxed->street3 = _value;
      }
      inline void street3(const char* _value)
      {
        _pd_boxed->street3 = _value;
      }
      inline void street3(const ::CORBA::String_var& _value)
      {
        _pd_boxed->street3 = _value;
      }

      inline const char* city() const
      {
        return _pd_boxed->city;
      }
      inline void city(char* _value)
      {
        _pd_boxed->city = _value;
      }
      inline void city(const char* _value)
      {
        _pd_boxed->city = _value;
      }
      inline void city(const ::CORBA::String_var& _value)
      {
        _pd_boxed->city = _value;
      }

      inline const char* stateorprovince() const
      {
        return _pd_boxed->stateorprovince;
      }
      inline void stateorprovince(char* _value)
      {
        _pd_boxed->stateorprovince = _value;
      }
      inline void stateorprovince(const char* _value)
      {
        _pd_boxed->stateorprovince = _value;
      }
      inline void stateorprovince(const ::CORBA::String_var& _value)
      {
        _pd_boxed->stateorprovince = _value;
      }

      inline const char* postalcode() const
      {
        return _pd_boxed->postalcode;
      }
      inline void postalcode(char* _value)
      {
        _pd_boxed->postalcode = _value;
      }
      inline void postalcode(const char* _value)
      {
        _pd_boxed->postalcode = _value;
      }
      inline void postalcode(const ::CORBA::String_var& _value)
      {
        _pd_boxed->postalcode = _value;
      }

      inline const char* country_code() const
      {
        return _pd_boxed->country_code;
      }
      inline void country_code(char* _value)
      {
        _pd_boxed->country_code = _value;
      }
      inline void country_code(const char* _value)
      {
        _pd_boxed->country_code = _value;
      }
      inline void country_code(const ::CORBA::String_var& _value)
      {
        _pd_boxed->country_code = _value;
      }

      inline const char* telephone() const
      {
        return _pd_boxed->telephone;
      }
      inline void telephone(char* _value)
      {
        _pd_boxed->telephone = _value;
      }
      inline void telephone(const char* _value)
      {
        _pd_boxed->telephone = _value;
      }
      inline void telephone(const ::CORBA::String_var& _value)
      {
        _pd_boxed->telephone = _value;
      }



    

      static DisclosablePostalAddress* _downcast(::CORBA::ValueBase*);

#ifdef OMNI_HAVE_COVARIANT_RETURNS
      virtual DisclosablePostalAddress* _copy_value();
#else
      virtual ::CORBA::ValueBase* _copy_value();
#endif

      // omniORB internal
      virtual const char* _NP_repositoryId() const;
      virtual const char* _NP_repositoryId(::CORBA::ULong& _hashval) const;

      virtual const _omni_ValueIds* _NP_truncatableIds() const;

      virtual ::CORBA::Boolean _NP_custom() const;
      virtual ::CORBA::Boolean _NP_box() const;

      virtual void* _ptrToValue(const char* id);

      static void _NP_marshal(DisclosablePostalAddress*, cdrStream&);
      static DisclosablePostalAddress* _NP_unmarshal(cdrStream&);

      virtual void _PR_marshal_state(cdrStream&) const;
      virtual void _PR_unmarshal_state(cdrStream&);
      virtual void _PR_copy_state(DisclosablePostalAddress*);

      static _core_attr const char* _PD_repoId;

    protected:
      ~DisclosablePostalAddress();
    private:
      void operator=(const DisclosablePostalAddress&);

      PostalAddress_var _pd_boxed;
    };

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DisclosablePostalAddress;

    struct ObjectStatusDesc {
      typedef _CORBA_ConstrType_Variable_Var<ObjectStatusDesc> _var_type;

      
      ::CORBA::String_member handle;

      ::CORBA::String_member name;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef ObjectStatusDesc::_var_type ObjectStatusDesc_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< ObjectStatusDesc,ObjectStatusDesc_var > ObjectStatusDesc_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ObjectStatusDesc;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ObjectStatusDescSeq;

    class ObjectStatusDescSeq_var;

    class ObjectStatusDescSeq : public _CORBA_Unbounded_Sequence< ObjectStatusDesc >  {
    public:
      typedef ObjectStatusDescSeq_var _var_type;
      inline ObjectStatusDescSeq() {}
      inline ObjectStatusDescSeq(const ObjectStatusDescSeq& _s)
        : _CORBA_Unbounded_Sequence< ObjectStatusDesc > (_s) {}

      inline ObjectStatusDescSeq(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< ObjectStatusDesc > (_max) {}
      inline ObjectStatusDescSeq(_CORBA_ULong _max, _CORBA_ULong _len, ObjectStatusDesc* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< ObjectStatusDesc > (_max, _len, _val, _rel) {}

    

      inline ObjectStatusDescSeq& operator = (const ObjectStatusDescSeq& _s) {
        _CORBA_Unbounded_Sequence< ObjectStatusDesc > ::operator=(_s);
        return *this;
      }
    };

    class ObjectStatusDescSeq_out;

    class ObjectStatusDescSeq_var {
    public:
      inline ObjectStatusDescSeq_var() : _pd_seq(0) {}
      inline ObjectStatusDescSeq_var(ObjectStatusDescSeq* _s) : _pd_seq(_s) {}
      inline ObjectStatusDescSeq_var(const ObjectStatusDescSeq_var& _s) {
        if( _s._pd_seq )  _pd_seq = new ObjectStatusDescSeq(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~ObjectStatusDescSeq_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline ObjectStatusDescSeq_var& operator = (ObjectStatusDescSeq* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline ObjectStatusDescSeq_var& operator = (const ObjectStatusDescSeq_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new ObjectStatusDescSeq;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline ObjectStatusDesc& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline ObjectStatusDescSeq* operator -> () { return _pd_seq; }
      inline const ObjectStatusDescSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator ObjectStatusDescSeq& () const { return *_pd_seq; }
#else
      inline operator const ObjectStatusDescSeq& () const { return *_pd_seq; }
      inline operator ObjectStatusDescSeq& () { return *_pd_seq; }
#endif
        
      inline const ObjectStatusDescSeq& in() const { return *_pd_seq; }
      inline ObjectStatusDescSeq&       inout()    { return *_pd_seq; }
      inline ObjectStatusDescSeq*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline ObjectStatusDescSeq* _retn() { ObjectStatusDescSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class ObjectStatusDescSeq_out;
      
    private:
      ObjectStatusDescSeq* _pd_seq;
    };

    class ObjectStatusDescSeq_out {
    public:
      inline ObjectStatusDescSeq_out(ObjectStatusDescSeq*& _s) : _data(_s) { _data = 0; }
      inline ObjectStatusDescSeq_out(ObjectStatusDescSeq_var& _s)
        : _data(_s._pd_seq) { _s = (ObjectStatusDescSeq*) 0; }
      inline ObjectStatusDescSeq_out(const ObjectStatusDescSeq_out& _s) : _data(_s._data) {}
      inline ObjectStatusDescSeq_out& operator = (const ObjectStatusDescSeq_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline ObjectStatusDescSeq_out& operator = (ObjectStatusDescSeq* _s) {
        _data = _s;
        return *this;
      }
      inline operator ObjectStatusDescSeq*&()  { return _data; }
      inline ObjectStatusDescSeq*& ptr()       { return _data; }
      inline ObjectStatusDescSeq* operator->() { return _data; }

      inline ObjectStatusDesc& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      ObjectStatusDescSeq*& _data;

    private:
      ObjectStatusDescSeq_out();
      ObjectStatusDescSeq_out& operator=(const ObjectStatusDescSeq_var&);
    };

    struct Registrar {
      typedef _CORBA_ConstrType_Variable_Var<Registrar> _var_type;

      
      ::CORBA::String_member handle;

      ::CORBA::String_member organization;

      ::CORBA::String_member url;

      ::CORBA::String_member phone;

      PostalAddress address;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef Registrar::_var_type Registrar_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< Registrar,Registrar_var > Registrar_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Registrar;

    struct Domain {
      typedef _CORBA_ConstrType_Variable_Var<Domain> _var_type;

      
      ::CORBA::String_member handle;

      ::CORBA::String_member registrant_handle;

      StringSeq admin_contact_handles;

      ::CORBA::String_member nsset_handle;

      ::CORBA::String_member keyset_handle;

      ::CORBA::String_member registrar_handle;

      StringSeq statuses;

      DateTime registered;

      NullableDateTime_member changed;

      Date expire;

      NullableDateTime_member validated_to;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef Domain::_var_type Domain_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< Domain,Domain_var > Domain_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Domain;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DomainSeq;

    class DomainSeq_var;

    class DomainSeq : public _CORBA_Unbounded_Sequence< Domain >  {
    public:
      typedef DomainSeq_var _var_type;
      inline DomainSeq() {}
      inline DomainSeq(const DomainSeq& _s)
        : _CORBA_Unbounded_Sequence< Domain > (_s) {}

      inline DomainSeq(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< Domain > (_max) {}
      inline DomainSeq(_CORBA_ULong _max, _CORBA_ULong _len, Domain* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< Domain > (_max, _len, _val, _rel) {}

    

      inline DomainSeq& operator = (const DomainSeq& _s) {
        _CORBA_Unbounded_Sequence< Domain > ::operator=(_s);
        return *this;
      }
    };

    class DomainSeq_out;

    class DomainSeq_var {
    public:
      inline DomainSeq_var() : _pd_seq(0) {}
      inline DomainSeq_var(DomainSeq* _s) : _pd_seq(_s) {}
      inline DomainSeq_var(const DomainSeq_var& _s) {
        if( _s._pd_seq )  _pd_seq = new DomainSeq(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~DomainSeq_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline DomainSeq_var& operator = (DomainSeq* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline DomainSeq_var& operator = (const DomainSeq_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new DomainSeq;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline Domain& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline DomainSeq* operator -> () { return _pd_seq; }
      inline const DomainSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator DomainSeq& () const { return *_pd_seq; }
#else
      inline operator const DomainSeq& () const { return *_pd_seq; }
      inline operator DomainSeq& () { return *_pd_seq; }
#endif
        
      inline const DomainSeq& in() const { return *_pd_seq; }
      inline DomainSeq&       inout()    { return *_pd_seq; }
      inline DomainSeq*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline DomainSeq* _retn() { DomainSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class DomainSeq_out;
      
    private:
      DomainSeq* _pd_seq;
    };

    class DomainSeq_out {
    public:
      inline DomainSeq_out(DomainSeq*& _s) : _data(_s) { _data = 0; }
      inline DomainSeq_out(DomainSeq_var& _s)
        : _data(_s._pd_seq) { _s = (DomainSeq*) 0; }
      inline DomainSeq_out(const DomainSeq_out& _s) : _data(_s._data) {}
      inline DomainSeq_out& operator = (const DomainSeq_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline DomainSeq_out& operator = (DomainSeq* _s) {
        _data = _s;
        return *this;
      }
      inline operator DomainSeq*&()  { return _data; }
      inline DomainSeq*& ptr()       { return _data; }
      inline DomainSeq* operator->() { return _data; }

      inline Domain& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      DomainSeq*& _data;

    private:
      DomainSeq_out();
      DomainSeq_out& operator=(const DomainSeq_var&);
    };

    struct ContactIdentification {
      typedef _CORBA_ConstrType_Variable_Var<ContactIdentification> _var_type;

      
      ::CORBA::String_member identification_type;

      ::CORBA::String_member identification_data;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef ContactIdentification::_var_type ContactIdentification_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< ContactIdentification,ContactIdentification_var > ContactIdentification_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ContactIdentification;

#ifndef __Registry_mWhois_mDisclosableContactIdentification__
#define __Registry_mWhois_mDisclosableContactIdentification__

    class DisclosableContactIdentification;

    class DisclosableContactIdentification_Helper {
    public:
      static void add_ref(DisclosableContactIdentification*);
      static void remove_ref(DisclosableContactIdentification*);
      static void marshal(DisclosableContactIdentification*, cdrStream&);
      static DisclosableContactIdentification* unmarshal(cdrStream&);
    };

    typedef _CORBA_Value_Var    <DisclosableContactIdentification,DisclosableContactIdentification_Helper> DisclosableContactIdentification_var;
    typedef _CORBA_Value_Member <DisclosableContactIdentification,DisclosableContactIdentification_Helper> DisclosableContactIdentification_member;
    typedef _CORBA_Value_OUT_arg<DisclosableContactIdentification,DisclosableContactIdentification_Helper> DisclosableContactIdentification_out;

#endif // __Registry_mWhois_mDisclosableContactIdentification__

    class DisclosableContactIdentification :
      public ::CORBA::DefaultValueRefCountBase
    {
    public:
      typedef DisclosableContactIdentification_var _var_type;

      inline DisclosableContactIdentification() {
        _pd_boxed = new ContactIdentification();
      };
      inline DisclosableContactIdentification(const ContactIdentification& _v) {
        _pd_boxed = new ContactIdentification(_v);
      };
      inline DisclosableContactIdentification(const DisclosableContactIdentification& _v) :
        ValueBase (_v), DefaultValueRefCountBase (_v) {
        _pd_boxed = new ContactIdentification(_v._pd_boxed.in());
      };

      inline DisclosableContactIdentification& operator=(const ContactIdentification& _v) {
        _pd_boxed = new ContactIdentification(_v);
        return *this;
      }

      inline const ContactIdentification& _value() const {
        return _pd_boxed.in();
      }
      inline ContactIdentification& _value() {
        return _pd_boxed.inout();
      }
      inline void _value(const ContactIdentification& _v) {
        _pd_boxed = new ContactIdentification(_v);
      }

      inline const ContactIdentification& _boxed_in() const {
        return _pd_boxed.in();
      }
      inline ContactIdentification& _boxed_inout() {
        return _pd_boxed.inout();
      }
      inline ContactIdentification_out _boxed_out() {
        return _pd_boxed.out();
      }

      // Member accessors
      inline const char* identification_type() const
      {
        return _pd_boxed->identification_type;
      }
      inline void identification_type(char* _value)
      {
        _pd_boxed->identification_type = _value;
      }
      inline void identification_type(const char* _value)
      {
        _pd_boxed->identification_type = _value;
      }
      inline void identification_type(const ::CORBA::String_var& _value)
      {
        _pd_boxed->identification_type = _value;
      }

      inline const char* identification_data() const
      {
        return _pd_boxed->identification_data;
      }
      inline void identification_data(char* _value)
      {
        _pd_boxed->identification_data = _value;
      }
      inline void identification_data(const char* _value)
      {
        _pd_boxed->identification_data = _value;
      }
      inline void identification_data(const ::CORBA::String_var& _value)
      {
        _pd_boxed->identification_data = _value;
      }



    

      static DisclosableContactIdentification* _downcast(::CORBA::ValueBase*);

#ifdef OMNI_HAVE_COVARIANT_RETURNS
      virtual DisclosableContactIdentification* _copy_value();
#else
      virtual ::CORBA::ValueBase* _copy_value();
#endif

      // omniORB internal
      virtual const char* _NP_repositoryId() const;
      virtual const char* _NP_repositoryId(::CORBA::ULong& _hashval) const;

      virtual const _omni_ValueIds* _NP_truncatableIds() const;

      virtual ::CORBA::Boolean _NP_custom() const;
      virtual ::CORBA::Boolean _NP_box() const;

      virtual void* _ptrToValue(const char* id);

      static void _NP_marshal(DisclosableContactIdentification*, cdrStream&);
      static DisclosableContactIdentification* _NP_unmarshal(cdrStream&);

      virtual void _PR_marshal_state(cdrStream&) const;
      virtual void _PR_unmarshal_state(cdrStream&);
      virtual void _PR_copy_state(DisclosableContactIdentification*);

      static _core_attr const char* _PD_repoId;

    protected:
      ~DisclosableContactIdentification();
    private:
      void operator=(const DisclosableContactIdentification&);

      ContactIdentification_var _pd_boxed;
    };

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DisclosableContactIdentification;

    struct Contact {
      typedef _CORBA_ConstrType_Variable_Var<Contact> _var_type;

      
      ::CORBA::String_member handle;

      DisclosableString_member organization;

      DisclosableString_member name;

      DisclosablePostalAddress_member address;

      DisclosableString_member phone;

      DisclosableString_member fax;

      DisclosableString_member email;

      DisclosableString_member notify_email;

      DisclosableString_member vat_number;

      DisclosableContactIdentification_member identification;

      ::CORBA::String_member creating_registrar_handle;

      ::CORBA::String_member sponsoring_registrar_handle;

      DateTime created;

      NullableDateTime_member changed;

      StringSeq statuses;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef Contact::_var_type Contact_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< Contact,Contact_var > Contact_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Contact;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ContactSeq;

    class ContactSeq_var;

    class ContactSeq : public _CORBA_Unbounded_Sequence< Contact >  {
    public:
      typedef ContactSeq_var _var_type;
      inline ContactSeq() {}
      inline ContactSeq(const ContactSeq& _s)
        : _CORBA_Unbounded_Sequence< Contact > (_s) {}

      inline ContactSeq(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< Contact > (_max) {}
      inline ContactSeq(_CORBA_ULong _max, _CORBA_ULong _len, Contact* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< Contact > (_max, _len, _val, _rel) {}

    

      inline ContactSeq& operator = (const ContactSeq& _s) {
        _CORBA_Unbounded_Sequence< Contact > ::operator=(_s);
        return *this;
      }
    };

    class ContactSeq_out;

    class ContactSeq_var {
    public:
      inline ContactSeq_var() : _pd_seq(0) {}
      inline ContactSeq_var(ContactSeq* _s) : _pd_seq(_s) {}
      inline ContactSeq_var(const ContactSeq_var& _s) {
        if( _s._pd_seq )  _pd_seq = new ContactSeq(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~ContactSeq_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline ContactSeq_var& operator = (ContactSeq* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline ContactSeq_var& operator = (const ContactSeq_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new ContactSeq;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline Contact& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline ContactSeq* operator -> () { return _pd_seq; }
      inline const ContactSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator ContactSeq& () const { return *_pd_seq; }
#else
      inline operator const ContactSeq& () const { return *_pd_seq; }
      inline operator ContactSeq& () { return *_pd_seq; }
#endif
        
      inline const ContactSeq& in() const { return *_pd_seq; }
      inline ContactSeq&       inout()    { return *_pd_seq; }
      inline ContactSeq*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline ContactSeq* _retn() { ContactSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class ContactSeq_out;
      
    private:
      ContactSeq* _pd_seq;
    };

    class ContactSeq_out {
    public:
      inline ContactSeq_out(ContactSeq*& _s) : _data(_s) { _data = 0; }
      inline ContactSeq_out(ContactSeq_var& _s)
        : _data(_s._pd_seq) { _s = (ContactSeq*) 0; }
      inline ContactSeq_out(const ContactSeq_out& _s) : _data(_s._data) {}
      inline ContactSeq_out& operator = (const ContactSeq_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline ContactSeq_out& operator = (ContactSeq* _s) {
        _data = _s;
        return *this;
      }
      inline operator ContactSeq*&()  { return _data; }
      inline ContactSeq*& ptr()       { return _data; }
      inline ContactSeq* operator->() { return _data; }

      inline Contact& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      ContactSeq*& _data;

    private:
      ContactSeq_out();
      ContactSeq_out& operator=(const ContactSeq_var&);
    };

    struct NSSet {
      typedef _CORBA_ConstrType_Variable_Var<NSSet> _var_type;

      
      ::CORBA::String_member handle;

      StringSeq nservers;

      StringSeq tech_contact_handles;

      ::CORBA::String_member registrar_handle;

      DateTime created;

      NullableDateTime_member changed;

      StringSeq statuses;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef NSSet::_var_type NSSet_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< NSSet,NSSet_var > NSSet_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_NSSet;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_NSSetSeq;

    class NSSetSeq_var;

    class NSSetSeq : public _CORBA_Unbounded_Sequence< NSSet >  {
    public:
      typedef NSSetSeq_var _var_type;
      inline NSSetSeq() {}
      inline NSSetSeq(const NSSetSeq& _s)
        : _CORBA_Unbounded_Sequence< NSSet > (_s) {}

      inline NSSetSeq(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< NSSet > (_max) {}
      inline NSSetSeq(_CORBA_ULong _max, _CORBA_ULong _len, NSSet* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< NSSet > (_max, _len, _val, _rel) {}

    

      inline NSSetSeq& operator = (const NSSetSeq& _s) {
        _CORBA_Unbounded_Sequence< NSSet > ::operator=(_s);
        return *this;
      }
    };

    class NSSetSeq_out;

    class NSSetSeq_var {
    public:
      inline NSSetSeq_var() : _pd_seq(0) {}
      inline NSSetSeq_var(NSSetSeq* _s) : _pd_seq(_s) {}
      inline NSSetSeq_var(const NSSetSeq_var& _s) {
        if( _s._pd_seq )  _pd_seq = new NSSetSeq(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~NSSetSeq_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline NSSetSeq_var& operator = (NSSetSeq* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline NSSetSeq_var& operator = (const NSSetSeq_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new NSSetSeq;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline NSSet& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline NSSetSeq* operator -> () { return _pd_seq; }
      inline const NSSetSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator NSSetSeq& () const { return *_pd_seq; }
#else
      inline operator const NSSetSeq& () const { return *_pd_seq; }
      inline operator NSSetSeq& () { return *_pd_seq; }
#endif
        
      inline const NSSetSeq& in() const { return *_pd_seq; }
      inline NSSetSeq&       inout()    { return *_pd_seq; }
      inline NSSetSeq*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline NSSetSeq* _retn() { NSSetSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class NSSetSeq_out;
      
    private:
      NSSetSeq* _pd_seq;
    };

    class NSSetSeq_out {
    public:
      inline NSSetSeq_out(NSSetSeq*& _s) : _data(_s) { _data = 0; }
      inline NSSetSeq_out(NSSetSeq_var& _s)
        : _data(_s._pd_seq) { _s = (NSSetSeq*) 0; }
      inline NSSetSeq_out(const NSSetSeq_out& _s) : _data(_s._data) {}
      inline NSSetSeq_out& operator = (const NSSetSeq_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline NSSetSeq_out& operator = (NSSetSeq* _s) {
        _data = _s;
        return *this;
      }
      inline operator NSSetSeq*&()  { return _data; }
      inline NSSetSeq*& ptr()       { return _data; }
      inline NSSetSeq* operator->() { return _data; }

      inline NSSet& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      NSSetSeq*& _data;

    private:
      NSSetSeq_out();
      NSSetSeq_out& operator=(const NSSetSeq_var&);
    };

    struct DNSKey {
      typedef _CORBA_ConstrType_Variable_Var<DNSKey> _var_type;

      
      ::CORBA::Short flags;

      ::CORBA::Short protocol;

      ::CORBA::Short alg;

      ::CORBA::String_member public_key;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef DNSKey::_var_type DNSKey_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< DNSKey,DNSKey_var > DNSKey_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DNSKey;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DNSKeySeq;

    class DNSKeySeq_var;

    class DNSKeySeq : public _CORBA_Unbounded_Sequence< DNSKey >  {
    public:
      typedef DNSKeySeq_var _var_type;
      inline DNSKeySeq() {}
      inline DNSKeySeq(const DNSKeySeq& _s)
        : _CORBA_Unbounded_Sequence< DNSKey > (_s) {}

      inline DNSKeySeq(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< DNSKey > (_max) {}
      inline DNSKeySeq(_CORBA_ULong _max, _CORBA_ULong _len, DNSKey* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< DNSKey > (_max, _len, _val, _rel) {}

    

      inline DNSKeySeq& operator = (const DNSKeySeq& _s) {
        _CORBA_Unbounded_Sequence< DNSKey > ::operator=(_s);
        return *this;
      }
    };

    class DNSKeySeq_out;

    class DNSKeySeq_var {
    public:
      inline DNSKeySeq_var() : _pd_seq(0) {}
      inline DNSKeySeq_var(DNSKeySeq* _s) : _pd_seq(_s) {}
      inline DNSKeySeq_var(const DNSKeySeq_var& _s) {
        if( _s._pd_seq )  _pd_seq = new DNSKeySeq(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~DNSKeySeq_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline DNSKeySeq_var& operator = (DNSKeySeq* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline DNSKeySeq_var& operator = (const DNSKeySeq_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new DNSKeySeq;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline DNSKey& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline DNSKeySeq* operator -> () { return _pd_seq; }
      inline const DNSKeySeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator DNSKeySeq& () const { return *_pd_seq; }
#else
      inline operator const DNSKeySeq& () const { return *_pd_seq; }
      inline operator DNSKeySeq& () { return *_pd_seq; }
#endif
        
      inline const DNSKeySeq& in() const { return *_pd_seq; }
      inline DNSKeySeq&       inout()    { return *_pd_seq; }
      inline DNSKeySeq*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline DNSKeySeq* _retn() { DNSKeySeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class DNSKeySeq_out;
      
    private:
      DNSKeySeq* _pd_seq;
    };

    class DNSKeySeq_out {
    public:
      inline DNSKeySeq_out(DNSKeySeq*& _s) : _data(_s) { _data = 0; }
      inline DNSKeySeq_out(DNSKeySeq_var& _s)
        : _data(_s._pd_seq) { _s = (DNSKeySeq*) 0; }
      inline DNSKeySeq_out(const DNSKeySeq_out& _s) : _data(_s._data) {}
      inline DNSKeySeq_out& operator = (const DNSKeySeq_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline DNSKeySeq_out& operator = (DNSKeySeq* _s) {
        _data = _s;
        return *this;
      }
      inline operator DNSKeySeq*&()  { return _data; }
      inline DNSKeySeq*& ptr()       { return _data; }
      inline DNSKeySeq* operator->() { return _data; }

      inline DNSKey& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      DNSKeySeq*& _data;

    private:
      DNSKeySeq_out();
      DNSKeySeq_out& operator=(const DNSKeySeq_var&);
    };

    struct KeySet {
      typedef _CORBA_ConstrType_Variable_Var<KeySet> _var_type;

      
      ::CORBA::String_member handle;

      DNSKeySeq dns_keys;

      StringSeq tech_contact_handles;

      ::CORBA::String_member registrar_handle;

      DateTime created;

      NullableDateTime_member changed;

      StringSeq statuses;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef KeySet::_var_type KeySet_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< KeySet,KeySet_var > KeySet_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_KeySet;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_KeySetSeq;

    class KeySetSeq_var;

    class KeySetSeq : public _CORBA_Unbounded_Sequence< KeySet >  {
    public:
      typedef KeySetSeq_var _var_type;
      inline KeySetSeq() {}
      inline KeySetSeq(const KeySetSeq& _s)
        : _CORBA_Unbounded_Sequence< KeySet > (_s) {}

      inline KeySetSeq(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< KeySet > (_max) {}
      inline KeySetSeq(_CORBA_ULong _max, _CORBA_ULong _len, KeySet* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< KeySet > (_max, _len, _val, _rel) {}

    

      inline KeySetSeq& operator = (const KeySetSeq& _s) {
        _CORBA_Unbounded_Sequence< KeySet > ::operator=(_s);
        return *this;
      }
    };

    class KeySetSeq_out;

    class KeySetSeq_var {
    public:
      inline KeySetSeq_var() : _pd_seq(0) {}
      inline KeySetSeq_var(KeySetSeq* _s) : _pd_seq(_s) {}
      inline KeySetSeq_var(const KeySetSeq_var& _s) {
        if( _s._pd_seq )  _pd_seq = new KeySetSeq(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~KeySetSeq_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline KeySetSeq_var& operator = (KeySetSeq* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline KeySetSeq_var& operator = (const KeySetSeq_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new KeySetSeq;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline KeySet& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline KeySetSeq* operator -> () { return _pd_seq; }
      inline const KeySetSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator KeySetSeq& () const { return *_pd_seq; }
#else
      inline operator const KeySetSeq& () const { return *_pd_seq; }
      inline operator KeySetSeq& () { return *_pd_seq; }
#endif
        
      inline const KeySetSeq& in() const { return *_pd_seq; }
      inline KeySetSeq&       inout()    { return *_pd_seq; }
      inline KeySetSeq*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline KeySetSeq* _retn() { KeySetSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class KeySetSeq_out;
      
    private:
      KeySetSeq* _pd_seq;
    };

    class KeySetSeq_out {
    public:
      inline KeySetSeq_out(KeySetSeq*& _s) : _data(_s) { _data = 0; }
      inline KeySetSeq_out(KeySetSeq_var& _s)
        : _data(_s._pd_seq) { _s = (KeySetSeq*) 0; }
      inline KeySetSeq_out(const KeySetSeq_out& _s) : _data(_s._data) {}
      inline KeySetSeq_out& operator = (const KeySetSeq_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline KeySetSeq_out& operator = (KeySetSeq* _s) {
        _data = _s;
        return *this;
      }
      inline operator KeySetSeq*&()  { return _data; }
      inline KeySetSeq*& ptr()       { return _data; }
      inline KeySetSeq* operator->() { return _data; }

      inline KeySet& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      KeySetSeq*& _data;

    private:
      KeySetSeq_out();
      KeySetSeq_out& operator=(const KeySetSeq_var&);
    };

#ifndef __Registry_mWhois_mWhoisIntf__
#define __Registry_mWhois_mWhoisIntf__

    class WhoisIntf;
    class _objref_WhoisIntf;
    class _impl_WhoisIntf;
    
    typedef _objref_WhoisIntf* WhoisIntf_ptr;
    typedef WhoisIntf_ptr WhoisIntfRef;

    class WhoisIntf_Helper {
    public:
      typedef WhoisIntf_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_WhoisIntf, WhoisIntf_Helper> WhoisIntf_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_WhoisIntf,WhoisIntf_Helper > WhoisIntf_out;

#endif

    // interface WhoisIntf
    class WhoisIntf {
    public:
      // Declarations for this interface type.
      typedef WhoisIntf_ptr _ptr_type;
      typedef WhoisIntf_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      class OBJECT_NOT_FOUND : public ::CORBA::UserException {
      public:
        
        

        inline OBJECT_NOT_FOUND() {
          pd_insertToAnyFn    = insertToAnyFn;
          pd_insertToAnyFnNCP = insertToAnyFnNCP;
        }
        OBJECT_NOT_FOUND(const OBJECT_NOT_FOUND&);
        
        OBJECT_NOT_FOUND& operator=(const OBJECT_NOT_FOUND&);
        virtual ~OBJECT_NOT_FOUND();
        virtual void _raise() const;
        static OBJECT_NOT_FOUND* _downcast(::CORBA::Exception*);
        static const OBJECT_NOT_FOUND* _downcast(const ::CORBA::Exception*);
        static inline OBJECT_NOT_FOUND* _narrow(::CORBA::Exception* _e) {
          return _downcast(_e);
        }
        
        inline void operator>>=(cdrStream&) const { }
        inline void operator<<=(cdrStream&) { }

        static _core_attr insertExceptionToAny    insertToAnyFn;
        static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

        virtual ::CORBA::Exception* _NP_duplicate() const;

        static _core_attr const char* _PD_repoId;
        static _core_attr const char* _PD_typeId;

      private:
        virtual const char* _NP_typeId() const;
        virtual const char* _NP_repoId(int*) const;
        virtual void _NP_marshal(cdrStream&) const;
      };

      static _dyn_attr const ::CORBA::TypeCode_ptr _tc_OBJECT_NOT_FOUND;

      class INTERNAL_SERVER_ERROR : public ::CORBA::UserException {
      public:
        
        

        inline INTERNAL_SERVER_ERROR() {
          pd_insertToAnyFn    = insertToAnyFn;
          pd_insertToAnyFnNCP = insertToAnyFnNCP;
        }
        INTERNAL_SERVER_ERROR(const INTERNAL_SERVER_ERROR&);
        
        INTERNAL_SERVER_ERROR& operator=(const INTERNAL_SERVER_ERROR&);
        virtual ~INTERNAL_SERVER_ERROR();
        virtual void _raise() const;
        static INTERNAL_SERVER_ERROR* _downcast(::CORBA::Exception*);
        static const INTERNAL_SERVER_ERROR* _downcast(const ::CORBA::Exception*);
        static inline INTERNAL_SERVER_ERROR* _narrow(::CORBA::Exception* _e) {
          return _downcast(_e);
        }
        
        inline void operator>>=(cdrStream&) const { }
        inline void operator<<=(cdrStream&) { }

        static _core_attr insertExceptionToAny    insertToAnyFn;
        static _core_attr insertExceptionToAnyNCP insertToAnyFnNCP;

        virtual ::CORBA::Exception* _NP_duplicate() const;

        static _core_attr const char* _PD_repoId;
        static _core_attr const char* _PD_typeId;

      private:
        virtual const char* _NP_typeId() const;
        virtual const char* _NP_repoId(int*) const;
        virtual void _NP_marshal(cdrStream&) const;
      };

      static _dyn_attr const ::CORBA::TypeCode_ptr _tc_INTERNAL_SERVER_ERROR;

    
    };

    class _objref_WhoisIntf :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      Registrar* get_registrar_by_handle(const char* handle);
      Contact* get_contact_by_handle(const char* handle);
      NSSet* get_nsset_by_handle(const char* handle);
      NSSetSeq* get_nssets_by_ns(const char* handle);
      NSSetSeq* get_nssets_by_tech_c(const char* handle);
      KeySet* get_keyset_by_handle(const char* handle);
      KeySetSeq* get_keysets_by_tech_c(const char* handle);
      Domain* get_domain_by_handle(const char* handle);
      DomainSeq* get_domains_by_registrant(const char* handle);
      DomainSeq* get_domains_by_admin_contact(const char* handle);
      DomainSeq* get_domains_by_nsset(const char* handle);
      DomainSeq* get_domains_by_keyset(const char* handle);
      ObjectStatusDescSeq* get_domain_status_descriptions(const char* lang);
      ObjectStatusDescSeq* get_contact_status_descriptions(const char* lang);
      ObjectStatusDescSeq* get_nsset_status_descriptions(const char* lang);

      inline _objref_WhoisIntf()  { _PR_setobj(0); }  // nil
      _objref_WhoisIntf(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_WhoisIntf();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_WhoisIntf(const _objref_WhoisIntf&);
      _objref_WhoisIntf& operator = (const _objref_WhoisIntf&);
      // not implemented

      friend class WhoisIntf;
    };

    class _pof_WhoisIntf : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_WhoisIntf() : _OMNI_NS(proxyObjectFactory)(WhoisIntf::_PD_repoId) {}
      virtual ~_pof_WhoisIntf();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_WhoisIntf :
      public virtual omniServant
    {
    public:
      virtual ~_impl_WhoisIntf();

      virtual Registrar* get_registrar_by_handle(const char* handle) = 0;
      virtual Contact* get_contact_by_handle(const char* handle) = 0;
      virtual NSSet* get_nsset_by_handle(const char* handle) = 0;
      virtual NSSetSeq* get_nssets_by_ns(const char* handle) = 0;
      virtual NSSetSeq* get_nssets_by_tech_c(const char* handle) = 0;
      virtual KeySet* get_keyset_by_handle(const char* handle) = 0;
      virtual KeySetSeq* get_keysets_by_tech_c(const char* handle) = 0;
      virtual Domain* get_domain_by_handle(const char* handle) = 0;
      virtual DomainSeq* get_domains_by_registrant(const char* handle) = 0;
      virtual DomainSeq* get_domains_by_admin_contact(const char* handle) = 0;
      virtual DomainSeq* get_domains_by_nsset(const char* handle) = 0;
      virtual DomainSeq* get_domains_by_keyset(const char* handle) = 0;
      virtual ObjectStatusDescSeq* get_domain_status_descriptions(const char* lang) = 0;
      virtual ObjectStatusDescSeq* get_contact_status_descriptions(const char* lang) = 0;
      virtual ObjectStatusDescSeq* get_nsset_status_descriptions(const char* lang) = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_WhoisIntf;

  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE POA_Registry
_CORBA_MODULE_BEG

  _CORBA_MODULE Whois
  _CORBA_MODULE_BEG

    class WhoisIntf :
      public virtual Registry::Whois::_impl_WhoisIntf,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~WhoisIntf();

      inline ::Registry::Whois::WhoisIntf_ptr _this() {
        return (::Registry::Whois::WhoisIntf_ptr) _do_this(::Registry::Whois::WhoisIntf::_PD_repoId);
      }
    };

  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE OBV_Registry
_CORBA_MODULE_BEG

  _CORBA_MODULE Whois
  _CORBA_MODULE_BEG

  _CORBA_MODULE_END

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

void operator<<=(::CORBA::Any& _a, const Registry::Whois::StringSeq& _s);
void operator<<=(::CORBA::Any& _a, Registry::Whois::StringSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Registry::Whois::StringSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Registry::Whois::StringSeq*& _sp);

void operator<<=(::CORBA::Any& _a, Registry::Whois::DisclosableString* _s);
void operator<<=(::CORBA::Any& _a, Registry::Whois::DisclosableString** _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Registry::Whois::DisclosableString*& _s);

extern void operator<<=(::CORBA::Any& _a, const Registry::Whois::PostalAddress& _s);
extern void operator<<=(::CORBA::Any& _a, Registry::Whois::PostalAddress* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Registry::Whois::PostalAddress*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Registry::Whois::PostalAddress*& _sp);

void operator<<=(::CORBA::Any& _a, Registry::Whois::DisclosablePostalAddress* _s);
void operator<<=(::CORBA::Any& _a, Registry::Whois::DisclosablePostalAddress** _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Registry::Whois::DisclosablePostalAddress*& _s);

extern void operator<<=(::CORBA::Any& _a, const Registry::Whois::ObjectStatusDesc& _s);
extern void operator<<=(::CORBA::Any& _a, Registry::Whois::ObjectStatusDesc* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Registry::Whois::ObjectStatusDesc*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Registry::Whois::ObjectStatusDesc*& _sp);

void operator<<=(::CORBA::Any& _a, const Registry::Whois::ObjectStatusDescSeq& _s);
void operator<<=(::CORBA::Any& _a, Registry::Whois::ObjectStatusDescSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Registry::Whois::ObjectStatusDescSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Registry::Whois::ObjectStatusDescSeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const Registry::Whois::Registrar& _s);
extern void operator<<=(::CORBA::Any& _a, Registry::Whois::Registrar* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Registry::Whois::Registrar*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Registry::Whois::Registrar*& _sp);

extern void operator<<=(::CORBA::Any& _a, const Registry::Whois::Domain& _s);
extern void operator<<=(::CORBA::Any& _a, Registry::Whois::Domain* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Registry::Whois::Domain*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Registry::Whois::Domain*& _sp);

void operator<<=(::CORBA::Any& _a, const Registry::Whois::DomainSeq& _s);
void operator<<=(::CORBA::Any& _a, Registry::Whois::DomainSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Registry::Whois::DomainSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Registry::Whois::DomainSeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const Registry::Whois::ContactIdentification& _s);
extern void operator<<=(::CORBA::Any& _a, Registry::Whois::ContactIdentification* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Registry::Whois::ContactIdentification*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Registry::Whois::ContactIdentification*& _sp);

void operator<<=(::CORBA::Any& _a, Registry::Whois::DisclosableContactIdentification* _s);
void operator<<=(::CORBA::Any& _a, Registry::Whois::DisclosableContactIdentification** _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Registry::Whois::DisclosableContactIdentification*& _s);

extern void operator<<=(::CORBA::Any& _a, const Registry::Whois::Contact& _s);
extern void operator<<=(::CORBA::Any& _a, Registry::Whois::Contact* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Registry::Whois::Contact*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Registry::Whois::Contact*& _sp);

void operator<<=(::CORBA::Any& _a, const Registry::Whois::ContactSeq& _s);
void operator<<=(::CORBA::Any& _a, Registry::Whois::ContactSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Registry::Whois::ContactSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Registry::Whois::ContactSeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const Registry::Whois::NSSet& _s);
extern void operator<<=(::CORBA::Any& _a, Registry::Whois::NSSet* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Registry::Whois::NSSet*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Registry::Whois::NSSet*& _sp);

void operator<<=(::CORBA::Any& _a, const Registry::Whois::NSSetSeq& _s);
void operator<<=(::CORBA::Any& _a, Registry::Whois::NSSetSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Registry::Whois::NSSetSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Registry::Whois::NSSetSeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const Registry::Whois::DNSKey& _s);
extern void operator<<=(::CORBA::Any& _a, Registry::Whois::DNSKey* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Registry::Whois::DNSKey*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Registry::Whois::DNSKey*& _sp);

void operator<<=(::CORBA::Any& _a, const Registry::Whois::DNSKeySeq& _s);
void operator<<=(::CORBA::Any& _a, Registry::Whois::DNSKeySeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Registry::Whois::DNSKeySeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Registry::Whois::DNSKeySeq*& _sp);

extern void operator<<=(::CORBA::Any& _a, const Registry::Whois::KeySet& _s);
extern void operator<<=(::CORBA::Any& _a, Registry::Whois::KeySet* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Registry::Whois::KeySet*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Registry::Whois::KeySet*& _sp);

void operator<<=(::CORBA::Any& _a, const Registry::Whois::KeySetSeq& _s);
void operator<<=(::CORBA::Any& _a, Registry::Whois::KeySetSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Registry::Whois::KeySetSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Registry::Whois::KeySetSeq*& _sp);

void operator<<=(::CORBA::Any& _a, const Registry::Whois::WhoisIntf::OBJECT_NOT_FOUND& _s);
void operator<<=(::CORBA::Any& _a, const Registry::Whois::WhoisIntf::OBJECT_NOT_FOUND* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Registry::Whois::WhoisIntf::OBJECT_NOT_FOUND*& _sp);

void operator<<=(::CORBA::Any& _a, const Registry::Whois::WhoisIntf::INTERNAL_SERVER_ERROR& _s);
void operator<<=(::CORBA::Any& _a, const Registry::Whois::WhoisIntf::INTERNAL_SERVER_ERROR* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const Registry::Whois::WhoisIntf::INTERNAL_SERVER_ERROR*& _sp);

void operator<<=(::CORBA::Any& _a, Registry::Whois::WhoisIntf_ptr _s);
void operator<<=(::CORBA::Any& _a, Registry::Whois::WhoisIntf_ptr* _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, Registry::Whois::WhoisIntf_ptr& _s);



inline void
Registry::Whois::WhoisIntf::_marshalObjRef(::Registry::Whois::WhoisIntf_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_Whois2
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_Whois2
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_Whois2
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_Whois2
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_Whois2
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_Whois2
#endif

#endif  // __Whois2_hh__

