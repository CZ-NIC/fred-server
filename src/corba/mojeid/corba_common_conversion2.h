/*
 * Copyright (C) 2015  CZ.NIC, z.s.p.o.
 *
 * This file is part of FRED.
 *
 * FRED is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * FRED is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with FRED.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
*  @file
*  header of common corba types wrapper
*/
#ifndef CORBA_COMMON_CONVERSION2_H_9496EF7266599697662705CBCA48A492//date "+%s"|md5sum|tr "[a-f]" "[A-F]"
#define CORBA_COMMON_CONVERSION2_H_9496EF7266599697662705CBCA48A492

#include "util/db/nullable.h"

#include <string>
#include <omniORB4/CORBA.h>

/**
 * Template class for bidirectional conversions between CORBA and standard types.
 * @param C CORBA type
 */
template < typename C > struct corba_type_conversion;

/**
 * Template class for nonconst access to the CORBA variable.
 * @param C CORBA type
 */
template < typename C > struct corba_value_nonconst;

/**
 * Template function creates object for nonconst access to the CORBA variable.
 * @param v variable of CORBA type
 * @note this is the only way to create given corba_value_nonconst object
 */
template < typename C > corba_value_nonconst< C > corba_value(C &v);

/**
 * Specialization for CORBA type generated by _CORBA_Value_Var template.
 * @param v variable of CORBA type
 * @note this is the only way to create given corba_value_nonconst object
 */
template < typename TC, typename TH >
corba_value_nonconst< TC* > corba_value(_CORBA_Value_Var< TC, TH > &v);

/**
 * Specialization for CORBA type generated by _CORBA_Value_Member template.
 * @param v variable of CORBA type
 * @note this is the only way to create given corba_value_nonconst object
 */
template < typename TC, typename TH >
corba_value_nonconst< TC* > corba_value(_CORBA_Value_Member< TC, TH > &v);

template < typename CORBA_TYPE >
struct corba_value_nonconst
{
    typedef CORBA_TYPE corba_type;///< CORBA type

    /**
     * Converts value of CORBA type to corresponding value of given type.
     * @return corresponding value of given type
     */
    template < typename T >
    T get()const { T dst; return corba_type_conversion< corba_type >::set(dst, c); }

    /**
     * Converts value of CORBA type to corresponding std::string value.
     * @return corresponding std::string value
     */
    std::string get()const { return this->get< const char* >(); }

    /**
     * Converts value of CORBA type to corresponding value of given type.
     * @param dst variable that will be set
     * @return reference to parameter dst
     */
    template < typename T >
    T& get(T &dst)const { return corba_type_conversion< corba_type >::set(dst, c); }

    /**
     * Converts value of CORBA type to corresponding std::string value.
     * @param dst variable that will be set
     * @return reference to parameter dst
     */
    std::string& get(std::string &dst)const { const char *tmp; return dst = this->get(tmp); }

    /**
     * Converts value of CORBA type to corresponding value of given type.
     * @param dst variable that will be set
     * @param null_value represents null value in case CORBA type is nullable and CORBA value is null
     * @return reference to parameter dst
     */
    template < typename T >
    T& get(T &dst, const T &null_value)const { return corba_type_conversion< corba_type >::set(dst, c, null_value); }

    /**
     * Converts value of CORBA type to corresponding std::string value.
     * @param dst variable that will be set
     * @param null_value represents null value in case CORBA type is nullable and CORBA value is null
     * @return reference to parameter dst
     */
    std::string& get(std::string &dst, const std::string &null_value)const
    {
        const char *tmp;
        return dst = this->get(tmp, null_value.c_str());
    }

    /**
     * Converts value of given type to corresponding value of CORBA type.
     * @param src value that will be converted to CORBA type
     * @return reference to CORBA value
     */
    template < typename T >
    corba_type& set(const T &src) { return corba_type_conversion< corba_type >::set(c, src); }

    /**
     * Converts std::string value to corresponding value of CORBA type.
     * @param src value that will be converted to CORBA type
     * @return reference to CORBA value
     */
    corba_type& set(const std::string &src) { return this->set(src.c_str()); }
private:
    corba_value_nonconst(corba_type &v):c(v) { }
    corba_value_nonconst(const corba_value_nonconst &src):c(src.c) { }
    corba_type &c;
    friend corba_value_nonconst corba_value< corba_type >(corba_type&);
    template < typename TC, typename TH >
    friend corba_value_nonconst< TC* > corba_value(_CORBA_Value_Var< TC, TH >&);
    template < typename TC, typename TH >
    friend corba_value_nonconst< TC* > corba_value(_CORBA_Value_Member< TC, TH >&);
};

template < typename C >
corba_value_nonconst< C > corba_value(C &v) { return v; }

template < typename TC, typename TH >
corba_value_nonconst< TC* > corba_value(_CORBA_Value_Var< TC, TH > &v) { return v.inout(); }

template < typename TC, typename TH >
corba_value_nonconst< TC* > corba_value(_CORBA_Value_Member< TC, TH > &v) { return v.inout(); }

/**
 * Template class for constant access to the CORBA variable.
 * @param C CORBA type
 */
template < typename C > struct corba_value_const;

/**
 * Template function creates object for constant access to the CORBA variable.
 * @param v variable of CORBA type
 * @note this is the only way how to create given corba_value_nconst object
 */
template < typename C > corba_value_const< C > corba_value(const C&);

/**
 * Specialization for CORBA type generated by _CORBA_Value_Var template.
 * @param v variable of CORBA type
 * @note this is the only way how to create given corba_value_const object
 */
template < typename TC, typename TH >
corba_value_const< TC* > corba_value(const _CORBA_Value_Var< TC, TH >&);

/**
 * Specialization for CORBA type generated by _CORBA_Value_Member template.
 * @param v variable of CORBA type
 * @note this is the only way how to create given corba_value_const object
 */
template < typename TC, typename TH >
corba_value_const< TC* > corba_value(const _CORBA_Value_Member< TC, TH >&);

template < typename CORBA_TYPE >
struct corba_value_const
{
    typedef CORBA_TYPE corba_type;
    /**
     * Converts value of CORBA type to corresponding value of given type.
     * @return corresponding value of given type
     */
    template < typename T >
    T get()const { T dst; return corba_type_conversion< corba_type >::set(dst, c); }
    std::string get()const { return this->get< const char* >(); }

    /**
     * Converts value of CORBA type to corresponding value of given type.
     * @param dst variable that will be set
     * @return reference to parameter dst
     */
    template < typename T >
    T& get(T &dst)const { return corba_type_conversion< corba_type >::set(dst, c); }
    std::string& get(std::string &dst)const { const char *tmp; return dst = this->get(tmp); }

    /**
     * Converts value of CORBA type to corresponding value of given type.
     * @param dst variable that will be set
     * @param null_value represents null value in case CORBA type is nullable and CORBA value is null
     * @return reference to parameter dst
     */
    template < typename T >
    T& get(T &dst, const T &null_value)const { return corba_type_conversion< corba_type >::set(dst, c, null_value); }
    std::string& get(std::string &dst, const std::string &null_value)const
    {
        const char *tmp;
        return dst = this->get(tmp, null_value);
    }

    /**
     * Converts value of CORBA type to corresponding value of given type.
     * @param null_value represents null value in case CORBA type is nullable and CORBA value is null
     * @return converted value of given type
     */
    template < typename T >
    T get(const T &null_value)const { T dst; return this->get(dst, null_value); }
    std::string get(const std::string &null_value)const { return this->get(null_value.c_str()); }
private:
    corba_value_const(const corba_type &v):c(v) { }
    corba_value_const(const corba_value_const &src):c(src.c) { }
    const corba_type &c;
    friend corba_value_const corba_value< corba_type >(const corba_type&);
    template < typename TC, typename TH >
    friend corba_value_const< TC* > corba_value(const _CORBA_Value_Var< TC, TH >&);
    template < typename TC, typename TH >
    friend corba_value_const< TC* > corba_value(const _CORBA_Value_Member< TC, TH >&);
};

template < typename C >
corba_value_const< C > corba_value(const C &v) { return v; }

template < typename TC, typename TH >
corba_value_const< TC* > corba_value(const _CORBA_Value_Var< TC, TH > &v) { return static_cast< TC* >(v); }

template < typename TC, typename TH >
corba_value_const< TC* > corba_value(const _CORBA_Value_Member< TC, TH > &v) { return static_cast< TC* >(v); }

/**
 * Help template class uniformly names parameter type.
 * @param CORBA_TYPE CORBA type
 */
template < typename CORBA_TYPE >
struct corba_type_conversion_base
{
    typedef CORBA_TYPE corba_type;
};

/**
 * Specialization for ::CORBA::String_out
 */
template < >
struct corba_type_conversion< ::CORBA::String_out >
: corba_type_conversion_base< ::CORBA::String_out >
{
    /**
     * Set CORBA variable to given value.
     * @param dst CORBA variable to set
     * @param src given value
     * @return reference to dst variable
     */
    static corba_type& set(corba_type& dst, const char *src)
    {
        return dst = CORBA::string_dup(src);
    }
    /**
     * Get value of given type from CORBA variable.
     * @param dst variable of given type to set
     * @param src CORBA variable
     * @return reference to dst variable
     */
    static const char*& set(const char* &dst, const corba_type &src)
    {
        return dst = const_cast< corba_type& >(src).ptr();
    }
};

/**
 * Specialization for ::CORBA::String_var
 */
template < >
struct corba_type_conversion< ::CORBA::String_var >
: corba_type_conversion_base< ::CORBA::String_var >
{
    static corba_type& set(corba_type& dst, const char *src)
    {
        return dst = src;
    }
    static const char*& set(const char* &dst, const corba_type &src)
    {
        return dst = src.in();
    }
};

/**
 * Specialization for ::CORBA::String_member
 */
template < >
struct corba_type_conversion< ::CORBA::String_member >
: corba_type_conversion_base< ::CORBA::String_member >
{
    static corba_type& set(corba_type& dst, const char *src)
    {
        return dst = src;
    }
    static const char*& set(const char* &dst, const corba_type &src)
    {
        return dst = src.in();
    }
};

/**
 * Usable possibilities connected with CORBA nullable types.
 * @param NC nullable CORBA type
 */
template < typename NC >
struct nullable_corba_type
{
    /**
     * Creates CORBA nullable type from value of standard notnull type.
     * @param src value of standard notnull type
     * @return pointer to instance of CORBA nullable type
     * @note caller is responsible for object deallocation
     */
    template < typename T >
    static NC* create(const T &src) { return new NC(src); }
    /**
     * Creates CORBA nullable type from std::string value.
     * @param src std::string value
     * @return pointer to instance of CORBA nullable type
     * @note caller is responsible for object deallocation
     */
    static NC* create(const std::string &src) { return new NC(src.c_str()); }
};

template < typename NC >
struct corba_type_conversion< NC* >
{
    typedef NC *corba_type;
    template < typename T >
    static corba_type& set(corba_type &dst, const T &src)
    {
        return dst = nullable_corba_type< NC >::create(src);
    }
    template < typename T >
    static T& set(T &dst, const corba_type &src, const T &null_value)
    {
        if (src == NULL) {
            return dst = null_value;
        }
        return dst = T(src->_value());
    }
    template < typename T >
    static corba_type& set(corba_type &dst, const Nullable< T > &src)
    {
        if (src.isnull()) {
            return dst = static_cast< corba_type >(NULL);
        }
        return dst = nullable_corba_type< NC >::create(src.get_value());
    }
    template < typename T >
    static Nullable< T >& set(Nullable< T > &dst, const corba_type &src)
    {
        if (src == NULL) {
            return dst = Nullable< T >();
        }
        return dst = T(src->_value());
    }
};

#endif//CORBA_COMMON_CONVERSION2_H_9496EF7266599697662705CBCA48A492
