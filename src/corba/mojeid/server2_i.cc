/*
 * Copyright (C) 2015  CZ.NIC, z.s.p.o.
 *
 * This file is part of FRED.
 *
 * FRED is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * FRED is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with FRED.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 *  @file
 *  implementational code for mojeid2 IDL interface
 *  pregenerated by $> omniidl -bcxx -Wba -Wbexample -C./src/corba ~/workspace/enum/idl/idl/MojeID2.idl
 */

#include "src/corba/mojeid/server2_i.h"
#include "src/corba/mojeid/corba_conversion2.h"
#include "src/mojeid/mojeid2.h"

namespace Registry {
namespace MojeID {

typedef Server IDL;

Server_i::Server_i(const std::string &_server_name)
:   impl_ptr_(new MojeID2Impl(_server_name))
{
}

Server_i::~Server_i()
{
}

//   Methods corresponding to IDL attributes and operations
ContactId Server_i::create_contact_prepare(
    const CreateContact &_contact,
    const char *_trans_id,
    LogRequestId _log_request_id,
    ::CORBA::String_out _identification)
{
    try {
        Fred::InfoContactData contact;
        Corba::Conversion::from(_contact).into(contact);
        std::string ident;
        const ContactId contact_id = impl_ptr_->create_contact_prepare(
            contact,
            _trans_id,
            _log_request_id,
            ident);
        Corba::Conversion::into(_identification).from(ident);
        return contact_id;
    }
    catch (const MojeID2Impl::CreateContactPrepareError &e) {
        IDL::CREATE_CONTACT_PREPARE_VALIDATION_ERROR idl_error;
        Corba::Conversion::into(idl_error).from(e);
        throw idl_error;
    }
    catch (...) {
        throw IDL::INTERNAL_SERVER_ERROR();
    }
}//create_contact_prepare

Registry::MojeID::InfoContact* Server_i::transfer_contact_prepare(
        const char *_handle,
        const char *_trans_id,
        LogRequestId _log_request_id,
        ::CORBA::String_out _identification)
{
    try {
        Fred::InfoContactData contact;
        std::string ident;
        impl_ptr_->transfer_contact_prepare(
            _handle,
            _trans_id,
            _log_request_id,
            contact,
            ident);
        Corba::Conversion::into(_identification).from(ident);
        return Corba::Conversion::into(new Registry::MojeID::InfoContact).from(contact);
    }
    catch (const MojeID2Impl::TransferContactPrepareError &e) {
        IDL::TRANSFER_CONTACT_PREPARE_VALIDATION_ERROR idl_error;
        if (e.Fred::MojeID::Check::states_before_transfer_into_mojeid::mojeid_contact_present) {
            throw IDL::ALREADY_MOJEID_CONTACT();
        }
        if (e.Fred::MojeID::Check::states_before_transfer_into_mojeid::server_admin_blocked) {
            throw IDL::OBJECT_ADMIN_BLOCKED();
        }
        if (e.Fred::MojeID::Check::states_before_transfer_into_mojeid::server_user_blocked) {
            throw IDL::OBJECT_USER_BLOCKED();
        }
        Corba::Conversion::into(idl_error).from(e);
        throw idl_error;
    }
    catch (const MojeID2Impl::GetContact::object_doesnt_exist &e) {
        throw IDL::OBJECT_NOT_EXISTS();
    }
    catch (...) {
        throw IDL::INTERNAL_SERVER_ERROR();
    }
}//transfer_contact_prepare

void Server_i::update_contact_prepare(
        const UpdateContact &_new_data,
        const char *_trans_id,
        LogRequestId _log_request_id)
{
    try {
        Fred::InfoContactData new_data;
        Corba::Conversion::from(_new_data).into(new_data);
        impl_ptr_->update_contact_prepare(new_data, _trans_id, _log_request_id);
        return;
    }
    catch (const MojeID2Impl::UpdateContactPrepareError &e) {
        IDL::UPDATE_CONTACT_PREPARE_VALIDATION_ERROR idl_error;
        Corba::Conversion::into(idl_error).from(e);
        throw idl_error;
    }
    catch (const MojeID2Impl::MessageLimitExceeded &e) {
        IDL::MESSAGE_LIMIT_EXCEEDED idl_error;
        throw Corba::Conversion::into(idl_error).from(e);
    }
    catch (const MojeID2Impl::ObjectDoesntExist&) {
        throw IDL::OBJECT_NOT_EXISTS();
    }
    catch (...) {
        throw IDL::INTERNAL_SERVER_ERROR();
    }
}//update_contact_prepared

ContactId Server_i::process_registration_request(
        const char *ident_request_id,
        const char *password,
        LogRequestId log_request_id)
{
    try {
        return impl_ptr_->process_registration_request(ident_request_id, password, log_request_id);
    }
    catch (const MojeID2Impl::PublicRequestDoesntExist&) {
        throw IDL::IDENTIFICATION_REQUEST_NOT_EXISTS();
    }
    catch (const MojeID2Impl::IdentificationFailed&) {
        throw IDL::IDENTIFICATION_FAILED();
    }
    catch (const MojeID2Impl::IdentificationAlreadyProcessed&) {
        throw IDL::IDENTIFICATION_ALREADY_PROCESSED();
    }
    catch (const MojeID2Impl::IdentificationAlreadyInvalidated&) {
        throw IDL::IDENTIFICATION_ALREADY_INVALIDATED();
    }
    catch (const MojeID2Impl::ContactChanged&) {
        throw IDL::OBJECT_CHANGED();
    }
    catch (const MojeID2Impl::AlreadyMojeidContact&) {
        throw IDL::ALREADY_MOJEID_CONTACT();
    }
    catch (const MojeID2Impl::ObjectAdminBlocked&) {
        throw IDL::OBJECT_ADMIN_BLOCKED();
    }
    catch (const MojeID2Impl::ObjectUserBlocked&) {
        throw IDL::OBJECT_USER_BLOCKED();
    }
    catch (...) {
        throw IDL::INTERNAL_SERVER_ERROR();
    }
}//process_registration_request

void Server_i::process_identification_request(
        ContactId contact_id,
        const char *password,
        LogRequestId log_request_id)
{
    try {
        impl_ptr_->process_identification_request(contact_id, password, log_request_id);
    }
    catch (...) {
        throw IDL::INTERNAL_SERVER_ERROR();
    }
}//process_identification_request

void Server_i::commit_prepared_transaction(
        const char *_trans_id)
{
    try {
        impl_ptr_->commit_prepared_transaction(_trans_id);
    }
    catch (...) {
        throw IDL::INTERNAL_SERVER_ERROR();
    }
}//commit_prepared_transaction

void Server_i::rollback_prepared_transaction(
        const char *_trans_id)
{
    try {
        impl_ptr_->rollback_prepared_transaction(_trans_id);
    }
    catch (...) {
        throw IDL::INTERNAL_SERVER_ERROR();
    }
}//rollback_prepared_transaction

Buffer* Server_i::get_validation_pdf(
        ContactId _contact_id)
{
    try {
        const std::string pdf_content = impl_ptr_->get_validation_pdf(_contact_id);
        return Corba::Conversion::Into< Buffer* >::BasedOn< _CORBA_Unbounded_Sequence_Octet >::from(pdf_content);
    }
    catch (const MojeID2Impl::ObjectDoesntExist&) {
        throw IDL::OBJECT_NOT_EXISTS();
    }
    catch (...) {
        throw IDL::INTERNAL_SERVER_ERROR();
    }
}//get_validation_pdf

void Server_i::create_validation_request(
        ContactId _contact_id,
        LogRequestId _log_request_id)
{
    try {
        impl_ptr_->create_validation_request(_contact_id, _log_request_id);
    }
    catch (const MojeID2Impl::ObjectDoesntExist&) {
        throw IDL::OBJECT_NOT_EXISTS();
    }
    catch (const MojeID2Impl::ValidationRequestExists&) {
        throw IDL::OBJECT_EXISTS();
    }
    catch (const MojeID2Impl::ValidationAlreadyProcessed&) {
        throw IDL::VALIDATION_ALREADY_PROCESSED();
    }
    catch (const MojeID2Impl::CreateValidationRequestError &e) {
        IDL::CREATE_VALIDATION_REQUEST_VALIDATION_ERROR idl_error;
        Corba::Conversion::into(idl_error).from(e);
        throw idl_error;
    }
    catch (...) {
        throw IDL::INTERNAL_SERVER_ERROR();
    }
}//create_validation_request

ContactStateInfoList* Server_i::get_contacts_state_changes(
        ::CORBA::ULong _last_hours)
{
    try {
        ContactStateDataList contacts_state_changes;
        impl_ptr_->get_contacts_state_changes(_last_hours, contacts_state_changes);
        return Corba::Conversion::into(new ContactStateInfoList).from(contacts_state_changes);
    }
    catch (...) {
        throw IDL::INTERNAL_SERVER_ERROR();
    }
}//get_contacts_state_changes

ContactStateInfo* Server_i::get_contact_state(
        ContactId _contact_id)
{
    try {
        ContactStateData data;
        impl_ptr_->get_contact_state(_contact_id, data);
        return Corba::Conversion::into(new ContactStateInfo).from(data);
    }
    catch (const MojeID2Impl::ObjectDoesntExist&) {
        throw IDL::OBJECT_NOT_EXISTS();
    }
    catch (...) {
        throw IDL::INTERNAL_SERVER_ERROR();
    }
}//get_contact_state

void Server_i::cancel_account_prepare(
        ContactId _contact_id,
        const char *_trans_id,
        LogRequestId _log_request_id)
{
    try {
        const std::string trans_id = Corba::Conversion::from(_trans_id).into< std::string >();
        impl_ptr_->cancel_account_prepare(_contact_id, trans_id, _log_request_id);
    }
    catch (const MojeID2Impl::ObjectDoesntExist&) {
        throw IDL::OBJECT_NOT_EXISTS();
    }
    catch (...) {
        throw IDL::INTERNAL_SERVER_ERROR();
    }
}//cancel_account_prepare

ContactHandleList* Server_i::get_unregistrable_handles()
{
    try {
        HandleList unregistrable_handles;
        impl_ptr_->get_unregistrable_contact_handles(unregistrable_handles);
        return Corba::Conversion::into(new ContactHandleList).from(unregistrable_handles);
    }
    catch (...) {
        throw IDL::INTERNAL_SERVER_ERROR();
    }
}//get_unregistrable_handles

void Server_i::send_new_pin3(
      ContactId contact_id,
      LogRequestId log_request_id)
{
    try {
        impl_ptr_->send_new_pin3(contact_id, log_request_id);
    }
    catch (const MojeID2Impl::MessageLimitExceeded &e) {
        IDL::MESSAGE_LIMIT_EXCEEDED idl_error;
        throw Corba::Conversion::into(idl_error).from(e);
    }
    catch (const MojeID2Impl::PublicRequestDoesntExist&) {
        throw IDL::IDENTIFICATION_REQUEST_NOT_EXISTS();
    }
    catch (const MojeID2Impl::ObjectDoesntExist&) {
        throw IDL::OBJECT_NOT_EXISTS();
    }
    catch (...) {
        throw IDL::INTERNAL_SERVER_ERROR();
    }
}

void Server_i::send_mojeid_card(
      ContactId contact_id,
      LogRequestId log_request_id)
{
    try {
        impl_ptr_->send_mojeid_card(contact_id, log_request_id);
    }
    catch (const MojeID2Impl::MessageLimitExceeded &e) {
        IDL::MESSAGE_LIMIT_EXCEEDED idl_error;
        throw Corba::Conversion::into(idl_error).from(e);
    }
    catch (const MojeID2Impl::PublicRequestDoesntExist&) {
        throw IDL::IDENTIFICATION_REQUEST_NOT_EXISTS();
    }
    catch (const MojeID2Impl::ObjectDoesntExist&) {
        throw IDL::OBJECT_NOT_EXISTS();
    }
    catch (...) {
        throw IDL::INTERNAL_SERVER_ERROR();
    }
}

void Server_i::generate_sms_messages()
{
    try {
        impl_ptr_->generate_sms_messages();
    }
    catch (...) {
        throw IDL::INTERNAL_SERVER_ERROR();
    }
}

void Server_i::enable_sms_messages_generation(::CORBA::Boolean enable)
{
    try {
        impl_ptr_->enable_sms_messages_generation(enable);
    }
    catch (...) {
        throw IDL::INTERNAL_SERVER_ERROR();
    }
}

void Server_i::generate_email_messages()
{
    try {
        impl_ptr_->generate_email_messages();
    }
    catch (...) {
        throw IDL::INTERNAL_SERVER_ERROR();
    }
}

void Server_i::enable_email_messages_generation(::CORBA::Boolean enable)
{
    try {
        impl_ptr_->enable_email_messages_generation(enable);
    }
    catch (...) {
        throw IDL::INTERNAL_SERVER_ERROR();
    }
}

void Server_i::generate_letter_messages()
{
    try {
        impl_ptr_->generate_letter_messages();
    }
    catch (...) {
        throw IDL::INTERNAL_SERVER_ERROR();
    }
}

void Server_i::enable_letter_messages_generation(::CORBA::Boolean enable)
{
    try {
        impl_ptr_->enable_letter_messages_generation(enable);
    }
    catch (...) {
        throw IDL::INTERNAL_SERVER_ERROR();
    }
}

ContactId Server_i::get_contact_id(
        const char *_handle)
{
    return 0;
}//get_contact_id

char* Server_i::get_contact_authinfo(
        ContactId contact_id)
{
    return NULL;
}

void Server_i::corba_conversion_test(const Test &ct, Test &t, ::CORBA::String_out so, ::CORBA::String_var sv,
                                     ::CORBA::String_member sm)
{
    const char *cs;
    std::string s;
    Nullable< std::string > ns;

    ns = Corba::Conversion::from(ct.var).into< Nullable< std::string > >();
    ns = Corba::Conversion::from(ct.var).into< std::string >();
    ns = Corba::Conversion::from(ct.var).into(ns);
//    cs = Corba::Conversion::from(ct.var).into(cs);
    s  = Corba::Conversion::from(ct.var).into(s);
    cs = Corba::Conversion::from(ct.var).into(cs, "NULL");
    s  = Corba::Conversion::from(ct.var).into(s, "NULL");
    cs = Corba::Conversion::from(ct.var).into(cs, "NULL");
    s  = Corba::Conversion::from(ct.var).into(s, "NULL");
    Corba::Conversion::into(t.var).from(cs);
    Corba::Conversion::into(t.var).from(s);
    Corba::Conversion::into(t.var).from(ns);

    ns = Corba::Conversion::from(ct.member).into< std::string >();
    ns = Corba::Conversion::from(ct.member).into(ns);
//    cs = Corba::Conversion::from(ct.member).into(cs);
    s  = Corba::Conversion::from(ct.member).into(s);
    cs = Corba::Conversion::from(ct.member).into(cs, "NULL");
    s  = Corba::Conversion::from(ct.member).into(s, "NULL");
    Corba::Conversion::into(t.member).from(cs);
    Corba::Conversion::into(t.member).from(s);
    Corba::Conversion::into(t.member).from(ns);

    Corba::Conversion::into(so).from(cs);
    Corba::Conversion::into(so).from(s);

//    cs = Corba::Conversion::from(sv).into< const char* >();
    s  = Corba::Conversion::from(sv).into< std::string >();
//    cs = Corba::Conversion::from(sv).into(cs);
    s  = Corba::Conversion::from(sv).into(s);
    Corba::Conversion::into(sv).from(cs);
    Corba::Conversion::into(sv).from(s);

//    cs = Corba::Conversion::from(sm).into< const char* >();
    s  = Corba::Conversion::from(sm).into< std::string >();
//    cs = Corba::Conversion::from(sm).into(cs);
    s  = Corba::Conversion::from(sm).into(s);
    Corba::Conversion::into(sm).from(cs);
    Corba::Conversion::into(sm).from(s);

    DateTime dt;
    boost::posix_time::ptime pt = Corba::Conversion::from(dt).into< boost::posix_time::ptime >();
    pt = Corba::Conversion::from(dt).into(pt);
    Corba::Conversion::into(dt).from(pt);
}

}//namespace Registry::MojeID
}//namespace Registry
