/*
 * Copyright (C) 2015  CZ.NIC, z.s.p.o.
 *
 * This file is part of FRED.
 *
 * FRED is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * FRED is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with FRED.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 *  @file
 *  implementational code for mojeid2 IDL interface
 *  pregenerated by $> omniidl -bcxx -Wba -Wbexample -C./src/corba ~/workspace/enum/idl/idl/MojeID2.idl
 */

#include "src/corba/mojeid/server2_i.h"
#include "src/corba/mojeid/corba_conversion2.h"
#include "src/mojeid/mojeid2.h"

namespace Registry {
namespace MojeID {

Server_i::Server_i(const std::string &_server_name)
:   impl_ptr_(new MojeID2Impl(_server_name))
{
}

Server_i::~Server_i()
{
}

//   Methods corresponding to IDL attributes and operations
::CORBA::ULongLong Server_i::create_contact_prepare(
    const CreateContact &_contact,
    const char *_trans_id,
    ::CORBA::ULongLong _log_request_id,
    ::CORBA::String_out _identification)
{
    return 0;
}//create_contact_prepare

Registry::MojeID::InfoContact* Server_i::transfer_contact_prepare(
        const char *_handle,
        const char *_trans_id,
        ::CORBA::ULongLong _log_request_id,
        ::CORBA::String_out _identification)
{
    return NULL;
}//transfer_contact_prepare

void Server_i::update_contact_prepared(
        const UpdateContact &_contact,
        const char *_trans_id,
        ::CORBA::ULongLong _log_request_id)
{
}//update_contact_prepared

::CORBA::ULongLong Server_i::process_registration_request(
        const char *ident_request_id,
        const char *password,
        ::CORBA::ULongLong log_request_id)
{
    return 0;
}//processIdentification

void Server_i::process_identification_request(
        ::CORBA::ULongLong contact_id,
        const char *password,
        ::CORBA::ULongLong log_request_id)
{
}

void Server_i::commit_prepared_transaction(
        const char *_trans_id)
{
}//commit_prepared_transaction

void Server_i::rollback_prepared_transaction(
        const char *_trans_id)
{
}//rollback_prepared_transaction

Buffer* Server_i::get_validation_pdf(
        ::CORBA::ULongLong _contact_id)
{
    return NULL;
}//get_validation_pdf

void Server_i::create_validation_request(
        ::CORBA::ULongLong _contact_id,
        ::CORBA::ULongLong _log_request_id)
{
}//create_validation_request

ContactStateInfoList* Server_i::get_contacts_state_changes(
        ::CORBA::ULong _last_hours)
{
    return NULL;
}//get_contacts_state_changes

ContactStateInfo* Server_i::get_contact_state(
        ::CORBA::ULongLong _contact_id)
{
    return NULL;
}//get_contact_state

void Server_i::cancel_contact_account_prepare(
        ::CORBA::ULongLong _contact_id,
        const char *_trans_id,
        ::CORBA::ULongLong _log_request_id)
{
}//cancel_contact_account_prepare

ContactHandleList* Server_i::get_unregistrable_handles(
        ::CORBA::ULong _chunk_size,
        ::CORBA::ULongLong &_start_from)
{
    try {
        HandleList chunk;
        Fred::OperationContext _ctx;
        ContactId last_contact_id = _start_from;
        impl_ptr_->get_unregistrable_contact_handles(_ctx, _chunk_size, last_contact_id, chunk);
        ContactHandleList_var ret = new ContactHandleList;
        ret->length(0);

        for (::size_t idx = 0; idx < chunk.size(); ++idx) {
            ret->length(idx + 1);
            ret[idx] = chunk[idx].c_str();
        }

        _start_from = last_contact_id;
        return ret._retn();
    }
    catch (...) {
        throw Registry::MojeID::Server::INTERNAL_SERVER_ERROR();
    }
}//get_unregistrable_handles

void Server_i::send_new_pin3(
      ::CORBA::ULongLong contact_id,
      ::CORBA::ULongLong log_request_id)
{
}

void Server_i::send_mojeid_card(
      ::CORBA::ULongLong contact_id,
      ::CORBA::ULongLong log_request_id)
{
}

::CORBA::ULongLong Server_i::get_contact_id(
        const char *_handle)
{
    return 0;
}//get_contact_id

char* Server_i::get_contact_authinfo(
        ::CORBA::ULongLong contact_id)
{
    return NULL;
}

void Server_i::corba_conversion_test(CreateContact &c, ::CORBA::String_out so)
{
    corba_value(so).set(std::string("nazdar"));
    corba_value(so).set(static_cast< const char* >("prde"));
    Nullable< std::string > organization;
    corba_value(c.organization.in()).get(organization);
    organization = corba_value(c.organization.in()).get< Nullable< std::string > >();
    std::string username;
    corba_value(c.username).get(username);
    corba_value(c.username).set(username);
    DateTime dt;
    boost::posix_time::ptime t = corba_value(dt).get< boost::posix_time::ptime >();
    corba_value(dt).set(t);
}

}//namespace Registry::MojeID
}//namespace Registry
