/*
 * Copyright (C) 2010  CZ.NIC, z.s.p.o.
 *
 * This file is part of FRED.
 *
 * FRED is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * FRED is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with FRED.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 *  @hpmail.h
 *  hybrid postservice simple interface header
 */

#ifndef HPMAIL_H_
#define HPMAIL_H_

#include <cstdio>
#include <memory>
#include <vector>
#include <map>
#include <string>
#include <stdexcept>
#include <iostream>
#include <exception>
#include <vector>

#include <boost/program_options.hpp>
#include <boost/utility.hpp>

#include "faked_args.h"
#include "handle_args.h"

#include "hp.h"

/**
 * \class HPMail
 * \brief interface for uploading to hybrid postservice
 *  one instance per process and non-concurrent use only
 *  , using curl easy interface and 7z executable
 */

typedef std::vector<char> MailFile;//one mail file data
typedef std::vector<MailFile> MailBatch;//all batch files
typedef std::map<std::string, std::string> HPCfgMap;//postservice config map
typedef std::vector<std::string> LetterFileNames; // vector of files to compress
typedef std::vector<std::string> VolumeFileNames; // vector of files to upload

class HPMail : boost::noncopyable
{
    HPCfgMap config_; //runtime configuration
    std::string phpsessid_; //PHP session id
    std::string curl_log_file_name_;//curl log file name
    FILESharedPtr curl_log_file_guard_;//curl log file pointer guard
    std::string hp_batch_number_; // batch number generated by login
    std::size_t letter_file_number_; // file number of letter to compress
    LetterFileNames letter_file_names_; // list of files to compress
    bool saved_file_for_upload_; //have some file for upload
    bool compressed_file_for_upload_; //have some compressed file for upload

    static HPCfgMap required_config;//required postservice config with default values
    static std::auto_ptr<HPMail> instance_ptr;
    friend class std::auto_ptr<HPMail>;
protected:
    ~HPMail(){}//dtor
private:
    //ctor
    HPMail( const HPCfgMap& config)
    : config_ (config) //copy first
    , phpsessid_("") //initially empty, filled by succesful login
    , curl_log_file_name_( config_["hp_upload_curlopt_stderr_log"].empty()
            ? std::string("")
            : (config_["mb_proc_tmp_dir"] + config_["hp_upload_curlopt_stderr_log"])
            )
    , curl_log_file_guard_( curl_log_file_name_.empty()
            ? static_cast<FILE*>(stderr)
            : fopen(curl_log_file_name_.c_str(),"w"))
    , hp_batch_number_("") //initially empty, generated by succesful login
    , letter_file_number_() //initially 0
    , saved_file_for_upload_(false)//initially no files
    , compressed_file_for_upload_(false)//initially no files
    {}
    void save_list_for_archiver();
    VolumeFileNames load_compressed_mail_batch_filelist();
    void load_compressed_mail_volume(
            const std::string& compressed_mail_volume_filename
            , MailFile& out_mf);
    void upload_of_batch_by_filelist(
            VolumeFileNames& compressed_mail_batch_filelist);
    void end_of_batch(VolumeFileNames& compressed_mail_batch_filelist);
    void send_storno();
    std::string crc32_into_string(MailFile& mf);
public:
    static HPMail* set(const HPCfgMap& config_changes = HPCfgMap());
    static HPMail* get();

    void login(const std::string& loginame //postservice account name
        , const std::string& password //postservice account password
        , const std::string& batch_id //batch identificator like: "hpcb_Jednorazova_zakazka"
        , const std::string& batch_note //batch note like: "Testovaci prenos!!!" or anything else you need to tell here
        );
    void upload( const MailBatch& mb = MailBatch());
    void save_files_for_upload( const MailBatch& mb);
    void save_file_for_upload( const MailFile& mf);
    void archiver_command();

    static void init_connection();

};//class HPMail

/**
 * \class HandleHPMailArgs
 * \brief postservice client cmdline options handler
 */
class HandleHPMailArgs : public HandleArgs
{
public:
    std::string nameservice_host ;
    unsigned nameservice_port;
    std::string nameservice_context;

    boost::shared_ptr<boost::program_options::options_description>
    get_options_description()
    {
        boost::shared_ptr<boost::program_options::options_description> opts_descs(
                new boost::program_options::options_description(
                        std::string("Postservice client configuration")));
        /*
        opts_descs->add_options()
                ("nameservice.host", boost::program_options
                            ::value<std::string>()->default_value(std::string("localhost"))
                        , "nameservice host name")
                ("nameservice.port", boost::program_options
                            ::value<unsigned int>()->default_value(2809)
                             , "nameservice port number")
                ("nameservice.context", boost::program_options
                         ::value<std::string>()->default_value(std::string("fred"))
                     , "freds context in name service");
*/
        return opts_descs;
    }//get_options_description
    void handle( int argc, char* argv[],  FakedArgs &fa)
    {
        boost::program_options::variables_map vm;
        handler_parse_args(get_options_description(), vm, argc, argv, fa);
/*
        nameservice_host = (vm.count("nameservice.host") == 0
                ? std::string("localhost") : vm["nameservice.host"].as<std::string>());
        nameservice_port = (vm.count("nameservice.port") == 0
                ? 2809 : vm["nameservice.port"].as<unsigned>());
        nameservice_context = (vm.count("nameservice.context") == 0
                ? std::string("fred") : vm["nameservice.context"].as<std::string>());
        */
    }//handle
};//class HandleHPMailArgs


#endif // HPMAIL_H_
