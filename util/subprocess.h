/*
 * Copyright (C) 2014  CZ.NIC, z.s.p.o.
 *
 * This file is part of FRED.
 *
 * FRED is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2 of the License.
 *
 * FRED is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with FRED.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 *  @file subprocess.h
 *  sub-process related utils
 */


#ifndef SUBPROCESS_H_
#define SUBPROCESS_H_

#include <sys/types.h>
#include <sys/wait.h>
#include <sys/time.h>

#include <string>

#include <boost/noncopyable.hpp>

/**
 * @class SubProcessOutput
 * @brief shell command outputs and process exit status
 * 
 * Result of @ref ShellCmd::execute.
 */
struct SubProcessOutput
{
    std::string stdout; /**< contains standard output generated by process */
    std::string stderr; /**< contains error output generated by process */
    int status; /**< exit status of process */

    /**
     * Terminated normally
     * @return true if process terminated normally, that is, by calling exit
     *         or _exit, or by returning from main()
     */
    bool is_exited()const { return WIFEXITED(status); }

    /**
     * Exit status of the normally terminated process
     * @return The exit status of the child. This consists of the least significant
     *         8 bits of the status argument that the child specified in a call to
     *         exit or _exit or as the argument for a return statement in main().
     * @note @ref is_exited() must be true
     */
    int get_exit_status()const { return WEXITSTATUS(status); }

    /**
     * Terminated by a signal
     * @return true if the child process was terminated by a signal
     */
    bool is_signaled()const { return WIFSIGNALED(status); }

    /**
     * Number of the signal
     * @return the number of the signal that caused the child process to terminate
     * @note @ref is_signaled() must be true
     */
    int get_term_sig()const { return WTERMSIG(status); }

#ifdef WCOREDUMP
    /**
     * Produced a core dump
     * @return true if the child process produced a core dump
     */
    bool is_core_dump()const { return this->is_signaled() && (WCOREDUMP(status)); }
#endif
};

/**
 * @class ShellCmd
 * @brief shell command wrapper
 */
class ShellCmd:public boost::noncopyable
{
public:
    /**
     * @class RelativeTimeInSeconds
     * @brief Represents relative (from now) time meassured in seconds.
     */
    typedef typeof(::timeval().tv_sec) RelativeTimeInSeconds;

    /**
     * Constructor with mandatory parameters.
     * @param _cmd sets command into @ref cmd_ attribute
     */
    ShellCmd(const std::string &_cmd);

    /**
     * Constructor with mandatory parameters.
     * @param _cmd sets command into @ref cmd_ attribute
     * @param _timeout sets maximal command lifetime into @ref timeout_ attribute
     */
    ShellCmd(const std::string &_cmd,
             RelativeTimeInSeconds _timeout
            );

    /**
     * Constructor with all parameters.
     * @param _cmd sets command into @ref cmd_ attribute
     * @param _shell sets shell into @ref shell_ attribute
     * @param _timeout sets maximal command lifetime into @ref timeout_ attribute
     */
    ShellCmd(const std::string &_cmd,
             const std::string &_shell,
             RelativeTimeInSeconds _timeout
            );

    /**
     * @note Kills child process if one is already alive
     */
    ~ShellCmd();

    /**
     * Execute command in shell.
     * @param stdin_str data delivered to @ref cmd_ via standard input
     * @return command outputs and exit status
     * @note Sets and restores SIGCHLD handler
     * 
     * Run <em>echo $stdin_str|$shell_ -c "$cmd_"</em>
     */
    SubProcessOutput execute(std::string stdin_str = std::string());

private:
    const std::string cmd_; /**< Command executed by @ref shell_. */
    const std::string shell_; /**< Shell executes command @ref cmd_. */
    const RelativeTimeInSeconds timeout_; /**< Maximal command lifetime in seconds. */
    ::pid_t child_pid_;

    void kill_child(int *_status = NULL) throw();
};//class ShellCmd

#endif//SUBPROCESS_H_
