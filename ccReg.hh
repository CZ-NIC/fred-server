// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __ccReg_hh__
#define __ccReg_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_ccReg
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_ccReg
#endif






#ifdef USE_stub_in_nt_dll
#ifndef USE_core_stub_in_nt_dll
#define USE_core_stub_in_nt_dll
#endif
#ifndef USE_dyn_stub_in_nt_dll
#define USE_dyn_stub_in_nt_dll
#endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE ccReg

_CORBA_MODULE_BEG

  typedef CORBA::Short Response;
  typedef CORBA::Short_out Response_out;

  typedef CORBA::ULongLong timestamp;
  typedef CORBA::ULongLong_out timestamp_out;

  enum AddrType { IPv4, IPv6 /*, __max_AddrType=0xffffffff */ };
  typedef AddrType& AddrType_out;

  enum TransferFunc { Approve, Cancel, Query, Reject, Request /*, __max_TransferFunc=0xffffffff */ };
  typedef TransferFunc& TransferFunc_out;

  enum StatusToken { OK, Linked, clientDeleteProhibited, clientUpdateProhibited, pendingCreate, pendingDelete, pendingTransfer, serverDeleteProhibited, serverUpdateProhibited /*, __max_StatusToken=0xffffffff */ };
  typedef StatusToken& StatusToken_out;

  struct Address_Type {
    typedef _CORBA_ConstrType_Variable_Var<Address_Type> _var_type;

    
    CORBA::String_member address;

    CORBA::Short type;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef Address_Type::_var_type Address_Type_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< Address_Type,Address_Type_var > Address_Type_out;

  struct NameServer_Type {
    typedef _CORBA_ConstrType_Variable_Var<NameServer_Type> _var_type;

    
    CORBA::String_member name;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef NameServer_Type::_var_type NameServer_Type_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< NameServer_Type,NameServer_Type_var > NameServer_Type_out;

  class NameServer_var;

  class NameServer : public _CORBA_Unbounded_Sequence< NameServer_Type >  {
  public:
    typedef NameServer_var _var_type;
    inline NameServer() {}
    inline NameServer(const NameServer& _s)
      : _CORBA_Unbounded_Sequence< NameServer_Type > (_s) {}

    inline NameServer(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< NameServer_Type > (_max) {}
    inline NameServer(_CORBA_ULong _max, _CORBA_ULong _len, NameServer_Type* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< NameServer_Type > (_max, _len, _val, _rel) {}

  

    inline NameServer& operator = (const NameServer& _s) {
      _CORBA_Unbounded_Sequence< NameServer_Type > ::operator=(_s);
      return *this;
    }
  };

  class NameServer_out;

  class NameServer_var {
  public:
    inline NameServer_var() : _pd_seq(0) {}
    inline NameServer_var(NameServer* _s) : _pd_seq(_s) {}
    inline NameServer_var(const NameServer_var& _s) {
      if( _s._pd_seq )  _pd_seq = new NameServer(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~NameServer_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline NameServer_var& operator = (NameServer* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline NameServer_var& operator = (const NameServer_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new NameServer;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline NameServer_Type& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline NameServer* operator -> () { return _pd_seq; }
    inline const NameServer* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator NameServer& () const { return *_pd_seq; }
#else
    inline operator const NameServer& () const { return *_pd_seq; }
    inline operator NameServer& () { return *_pd_seq; }
#endif
      
    inline const NameServer& in() const { return *_pd_seq; }
    inline NameServer&       inout()    { return *_pd_seq; }
    inline NameServer*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline NameServer* _retn() { NameServer* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class NameServer_out;
    
  private:
    NameServer* _pd_seq;
  };

  class NameServer_out {
  public:
    inline NameServer_out(NameServer*& _s) : _data(_s) { _data = 0; }
    inline NameServer_out(NameServer_var& _s)
      : _data(_s._pd_seq) { _s = (NameServer*) 0; }
    inline NameServer_out(const NameServer_out& _s) : _data(_s._data) {}
    inline NameServer_out& operator = (const NameServer_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline NameServer_out& operator = (NameServer* _s) {
      _data = _s;
      return *this;
    }
    inline operator NameServer*&()  { return _data; }
    inline NameServer*& ptr()       { return _data; }
    inline NameServer* operator->() { return _data; }

    inline NameServer_Type& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    NameServer*& _data;

  private:
    NameServer_out();
    NameServer_out& operator=(const NameServer_var&);
  };

  class Address_var;

  class Address : public _CORBA_Unbounded_Sequence< Address_Type >  {
  public:
    typedef Address_var _var_type;
    inline Address() {}
    inline Address(const Address& _s)
      : _CORBA_Unbounded_Sequence< Address_Type > (_s) {}

    inline Address(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< Address_Type > (_max) {}
    inline Address(_CORBA_ULong _max, _CORBA_ULong _len, Address_Type* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< Address_Type > (_max, _len, _val, _rel) {}

  

    inline Address& operator = (const Address& _s) {
      _CORBA_Unbounded_Sequence< Address_Type > ::operator=(_s);
      return *this;
    }
  };

  class Address_out;

  class Address_var {
  public:
    inline Address_var() : _pd_seq(0) {}
    inline Address_var(Address* _s) : _pd_seq(_s) {}
    inline Address_var(const Address_var& _s) {
      if( _s._pd_seq )  _pd_seq = new Address(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~Address_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline Address_var& operator = (Address* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline Address_var& operator = (const Address_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new Address;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline Address_Type& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline Address* operator -> () { return _pd_seq; }
    inline const Address* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator Address& () const { return *_pd_seq; }
#else
    inline operator const Address& () const { return *_pd_seq; }
    inline operator Address& () { return *_pd_seq; }
#endif
      
    inline const Address& in() const { return *_pd_seq; }
    inline Address&       inout()    { return *_pd_seq; }
    inline Address*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline Address* _retn() { Address* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class Address_out;
    
  private:
    Address* _pd_seq;
  };

  class Address_out {
  public:
    inline Address_out(Address*& _s) : _data(_s) { _data = 0; }
    inline Address_out(Address_var& _s)
      : _data(_s._pd_seq) { _s = (Address*) 0; }
    inline Address_out(const Address_out& _s) : _data(_s._data) {}
    inline Address_out& operator = (const Address_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline Address_out& operator = (Address* _s) {
      _data = _s;
      return *this;
    }
    inline operator Address*&()  { return _data; }
    inline Address*& ptr()       { return _data; }
    inline Address* operator->() { return _data; }

    inline Address_Type& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    Address*& _data;

  private:
    Address_out();
    Address_out& operator=(const Address_var&);
  };

  class Status_var;

  class Status : public _CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::Short, 2, 2 >  {
  public:
    typedef Status_var _var_type;
    inline Status() {}
    inline Status(const Status& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::Short, 2, 2 > (_s) {}

    inline Status(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::Short, 2, 2 > (_max) {}
    inline Status(_CORBA_ULong _max, _CORBA_ULong _len, CORBA::Short* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::Short, 2, 2 > (_max, _len, _val, _rel) {}

  

    inline Status& operator = (const Status& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< CORBA::Short, 2, 2 > ::operator=(_s);
      return *this;
    }
  };

  class Status_out;

  class Status_var {
  public:
    inline Status_var() : _pd_seq(0) {}
    inline Status_var(Status* _s) : _pd_seq(_s) {}
    inline Status_var(const Status_var& _s) {
      if( _s._pd_seq )  _pd_seq = new Status(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~Status_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline Status_var& operator = (Status* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline Status_var& operator = (const Status_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new Status;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline CORBA::Short& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline Status* operator -> () { return _pd_seq; }
    inline const Status* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator Status& () const { return *_pd_seq; }
#else
    inline operator const Status& () const { return *_pd_seq; }
    inline operator Status& () { return *_pd_seq; }
#endif
      
    inline const Status& in() const { return *_pd_seq; }
    inline Status&       inout()    { return *_pd_seq; }
    inline Status*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline Status* _retn() { Status* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class Status_out;
    
  private:
    Status* _pd_seq;
  };

  class Status_out {
  public:
    inline Status_out(Status*& _s) : _data(_s) { _data = 0; }
    inline Status_out(Status_var& _s)
      : _data(_s._pd_seq) { _s = (Status*) 0; }
    inline Status_out(const Status_out& _s) : _data(_s._data) {}
    inline Status_out& operator = (const Status_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline Status_out& operator = (Status* _s) {
      _data = _s;
      return *this;
    }
    inline operator Status*&()  { return _data; }
    inline Status*& ptr()       { return _data; }
    inline Status* operator->() { return _data; }

    inline CORBA::Short& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    Status*& _data;

  private:
    Status_out();
    Status_out& operator=(const Status_var&);
  };

  struct Contact {
    typedef _CORBA_ConstrType_Variable_Var<Contact> _var_type;

    
    CORBA::String_member ROID;

    CORBA::String_member ClID;

    CORBA::String_member CrID;

    CORBA::String_member UpID;

    timestamp CrDate;

    timestamp UpDate;

    timestamp TrDate;

    CORBA::String_member Name;

    CORBA::String_member Organization;

    CORBA::String_member Street1;

    CORBA::String_member Street2;

    CORBA::String_member Street3;

    CORBA::String_member City;

    CORBA::String_member StateOrProvince;

    CORBA::String_member PostalCode;

    typedef CORBA::Char _0RL_Country[2];
    typedef CORBA::Char _Country_slice;

    CORBA::Char Country[2];

    CORBA::String_member Telephone;

    CORBA::String_member Fax;

    CORBA::String_member Email;

    CORBA::String_member NotifyEmail;

    CORBA::String_member VAT;

    typedef CORBA::Char _0RL_AuthInfoPw[32];
    typedef CORBA::Char _AuthInfoPw_slice;

    CORBA::Char AuthInfoPw[32];

    CORBA::Boolean DiscloseName;

    CORBA::Boolean DiscloseOrganization;

    CORBA::Boolean DiscloseAddress;

    CORBA::Boolean DiscloseTelephone;

    CORBA::Boolean DiscloseFax;

    CORBA::Boolean DiscloseEmail;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef Contact::_var_type Contact_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< Contact,Contact_var > Contact_out;

#ifndef __ccReg_mEPP__
#define __ccReg_mEPP__

  class EPP;
  class _objref_EPP;
  class _impl_EPP;
  
  typedef _objref_EPP* EPP_ptr;
  typedef EPP_ptr EPPRef;

  class EPP_Helper {
  public:
    typedef EPP_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_EPP, EPP_Helper> EPP_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_EPP,EPP_Helper > EPP_out;

#endif

  // interface EPP
  class EPP {
  public:
    // Declarations for this interface type.
    typedef EPP_ptr _ptr_type;
    typedef EPP_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_EPP :
    public virtual CORBA::Object,
    public virtual omniObjRef
  {
  public:
    Response Login(const char* clientID, const char* pass, const char* clTRID, CORBA::String_out errMsg, CORBA::String_out svTRID);
    Response Logout(const char* clTRID, CORBA::String_out errMsg, CORBA::String_out svTRID);
    Response ContactCheck(const char* roid, const char* clTRID, CORBA::String_out errMsg, CORBA::String_out svTRID);
    Response ContactInfo(const char* roid, const char* clTRID, Contact_out c, CORBA::String_out errMsg, CORBA::String_out svTRID);
    Response ContactDelete(const char* roid, const char* clTRID, CORBA::String_out errMsg, CORBA::String_out svTRID);
    Response ContactUpdate(const Contact& c, const char* clTRID, CORBA::String_out errMsg, CORBA::String_out svTRID);
    Response ContactCreate(const Contact& c, const char* clTRID, CORBA::String_out errMsg, CORBA::String_out svTRID);
    char* clientID();

    inline _objref_EPP()  { _PR_setobj(0); }  // nil
    _objref_EPP(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_EPP();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_EPP(const _objref_EPP&);
    _objref_EPP& operator = (const _objref_EPP&);
    // not implemented

    friend class EPP;
  };

  class _pof_EPP : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_EPP() : _OMNI_NS(proxyObjectFactory)(EPP::_PD_repoId) {}
    virtual ~_pof_EPP();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_EPP :
    public virtual omniServant
  {
  public:
    virtual ~_impl_EPP();

    virtual Response Login(const char* clientID, const char* pass, const char* clTRID, CORBA::String_out errMsg, CORBA::String_out svTRID) = 0;
    virtual Response Logout(const char* clTRID, CORBA::String_out errMsg, CORBA::String_out svTRID) = 0;
    virtual Response ContactCheck(const char* roid, const char* clTRID, CORBA::String_out errMsg, CORBA::String_out svTRID) = 0;
    virtual Response ContactInfo(const char* roid, const char* clTRID, Contact_out c, CORBA::String_out errMsg, CORBA::String_out svTRID) = 0;
    virtual Response ContactDelete(const char* roid, const char* clTRID, CORBA::String_out errMsg, CORBA::String_out svTRID) = 0;
    virtual Response ContactUpdate(const Contact& c, const char* clTRID, CORBA::String_out errMsg, CORBA::String_out svTRID) = 0;
    virtual Response ContactCreate(const Contact& c, const char* clTRID, CORBA::String_out errMsg, CORBA::String_out svTRID) = 0;
    virtual char* clientID() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


  struct DomainWhois {
    typedef _CORBA_ConstrType_Variable_Var<DomainWhois> _var_type;

    
    CORBA::String_member name;

    CORBA::String_member description;

    CORBA::Short status;

    timestamp registered;

    timestamp expired;

    CORBA::String_member registrar;

    NameServer ns;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef DomainWhois::_var_type DomainWhois_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< DomainWhois,DomainWhois_var > DomainWhois_out;

#ifndef __ccReg_mWhois__
#define __ccReg_mWhois__

  class Whois;
  class _objref_Whois;
  class _impl_Whois;
  
  typedef _objref_Whois* Whois_ptr;
  typedef Whois_ptr WhoisRef;

  class Whois_Helper {
  public:
    typedef Whois_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Whois, Whois_Helper> Whois_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Whois,Whois_Helper > Whois_out;

#endif

  // interface Whois
  class Whois {
  public:
    // Declarations for this interface type.
    typedef Whois_ptr _ptr_type;
    typedef Whois_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_Whois :
    public virtual CORBA::Object,
    public virtual omniObjRef
  {
  public:
    DomainWhois* Domain(const char* name);

    inline _objref_Whois()  { _PR_setobj(0); }  // nil
    _objref_Whois(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_Whois();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_Whois(const _objref_Whois&);
    _objref_Whois& operator = (const _objref_Whois&);
    // not implemented

    friend class Whois;
  };

  class _pof_Whois : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_Whois() : _OMNI_NS(proxyObjectFactory)(Whois::_PD_repoId) {}
    virtual ~_pof_Whois();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_Whois :
    public virtual omniServant
  {
  public:
    virtual ~_impl_Whois();

    virtual DomainWhois* Domain(const char* name) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


#ifndef __ccReg_mAdmin__
#define __ccReg_mAdmin__

  class Admin;
  class _objref_Admin;
  class _impl_Admin;
  
  typedef _objref_Admin* Admin_ptr;
  typedef Admin_ptr AdminRef;

  class Admin_Helper {
  public:
    typedef Admin_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Admin, Admin_Helper> Admin_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Admin,Admin_Helper > Admin_out;

#endif

  // interface Admin
  class Admin {
  public:
    // Declarations for this interface type.
    typedef Admin_ptr _ptr_type;
    typedef Admin_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_Admin :
    public virtual CORBA::Object,
    public virtual omniObjRef
  {
  public:
    

    inline _objref_Admin()  { _PR_setobj(0); }  // nil
    _objref_Admin(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_Admin();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_Admin(const _objref_Admin&);
    _objref_Admin& operator = (const _objref_Admin&);
    // not implemented

    friend class Admin;
  };

  class _pof_Admin : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_Admin() : _OMNI_NS(proxyObjectFactory)(Admin::_PD_repoId) {}
    virtual ~_pof_Admin();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_Admin :
    public virtual omniServant
  {
  public:
    virtual ~_impl_Admin();

    
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


_CORBA_MODULE_END



_CORBA_MODULE POA_ccReg
_CORBA_MODULE_BEG

  class EPP :
    public virtual ccReg::_impl_EPP,
    public virtual PortableServer::ServantBase
  {
  public:
    virtual ~EPP();

    inline ::ccReg::EPP_ptr _this() {
      return (::ccReg::EPP_ptr) _do_this(::ccReg::EPP::_PD_repoId);
    }
  };

  class Whois :
    public virtual ccReg::_impl_Whois,
    public virtual PortableServer::ServantBase
  {
  public:
    virtual ~Whois();

    inline ::ccReg::Whois_ptr _this() {
      return (::ccReg::Whois_ptr) _do_this(::ccReg::Whois::_PD_repoId);
    }
  };

  class Admin :
    public virtual ccReg::_impl_Admin,
    public virtual PortableServer::ServantBase
  {
  public:
    virtual ~Admin();

    inline ::ccReg::Admin_ptr _this() {
      return (::ccReg::Admin_ptr) _do_this(::ccReg::Admin::_PD_repoId);
    }
  };

_CORBA_MODULE_END



_CORBA_MODULE OBV_ccReg
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

inline void operator >>=(ccReg::AddrType _e, cdrStream& s) {
  ::operator>>=((CORBA::ULong)_e, s);
}

inline void operator <<= (ccReg::AddrType& _e, cdrStream& s) {
  CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  switch (_0RL_e) {
    case ccReg::IPv4:

    case ccReg::IPv6:


    _e = (ccReg::AddrType) _0RL_e;
    break;
  default:
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(ccReg::TransferFunc _e, cdrStream& s) {
  ::operator>>=((CORBA::ULong)_e, s);
}

inline void operator <<= (ccReg::TransferFunc& _e, cdrStream& s) {
  CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  switch (_0RL_e) {
    case ccReg::Approve:

    case ccReg::Cancel:

    case ccReg::Query:

    case ccReg::Reject:

    case ccReg::Request:


    _e = (ccReg::TransferFunc) _0RL_e;
    break;
  default:
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (CORBA::CompletionStatus)s.completion());
  }
}

inline void operator >>=(ccReg::StatusToken _e, cdrStream& s) {
  ::operator>>=((CORBA::ULong)_e, s);
}

inline void operator <<= (ccReg::StatusToken& _e, cdrStream& s) {
  CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  switch (_0RL_e) {
    case ccReg::OK:

    case ccReg::Linked:

    case ccReg::clientDeleteProhibited:

    case ccReg::clientUpdateProhibited:

    case ccReg::pendingCreate:

    case ccReg::pendingDelete:

    case ccReg::pendingTransfer:

    case ccReg::serverDeleteProhibited:

    case ccReg::serverUpdateProhibited:


    _e = (ccReg::StatusToken) _0RL_e;
    break;
  default:
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (CORBA::CompletionStatus)s.completion());
  }
}



inline void
ccReg::EPP::_marshalObjRef(::ccReg::EPP_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
ccReg::Whois::_marshalObjRef(::ccReg::Whois_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
ccReg::Admin::_marshalObjRef(::ccReg::Admin_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_ccReg
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_ccReg
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_ccReg
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_ccReg
#endif

#endif  // __ccReg_hh__

